/*
- 为什么操作真实dom的增删改查是很慢的？
  - 一次执行dom操作的js代码的执行本身是非常快的；
  - 慢的是：
    - JS每次对DOM元素的访问都是跨引擎之间的访问，而且找到对应DOM也需要耗时，所以这种访问天然就比较慢
    - 重新构建DOMTree、CSSOMTree、RenderTree、LayoutTree、Repaint这一系列更新流程比较慢
      - 所以更新DOM的操作本身就是很慢的操作，比如：
        - element.appendChild(childElement)
        - element.className = 'xx'
        - element.style.height = '10px'
      - 多次连续的更新DOM【很可能】引起【多次】在内存中的pre-paint流程，也就是多次的慢操作，累积到一起就会引起主线程被占用很久，
        因此就会表现出明显的性能问题，比如：
        - 在一个列表里追加一个子元素，如果直接添加进去是很快的，执行需要重新结算新元素的和父元素的layout就行了；
          但是如果全部删除再重新构建整个列表就会很慢，因为所以的元素都需要在重新执行一遍完整的repaint流程

- 为什么不使用document.createDocumentFragment()来一次更新整个DOM？
  - 因为整个dom的更新就需要对所以dom都重新进行layout和repaint计算，
    如果只局部改变更新的节点，那就避免不了没有改变的元素的layout和repaint计算

- innerHTML vs appenchild()
  - 创建一个长列表，这两种方式的性能是基本一样的，没有区别

- 利用虚拟dom进行diff的方式来操作真实dom为什么能优化操作性能？
  - 主要是减少了dom操作的次数和dom操作的数量：
    - 计算出最优的操作，也就是降低操作次数，也就是降低了 layout 流程的次数
    - 尽量复用已有的元素，就减少了进行layout的元素的数量
    - 批量更新机制，避免了对同一个dom元素的多次访问
*/

/*
- diff算法
  - 只进行同级比较
  - 只对相同类型的节点进行比较
  - 可以复用的节点为：key相同且类型相同
  - 算法复杂度为O(n)

- 不能用index拼接其它值的形式来设置key
  - 因为这样会导致相同的数据，因为index变化了就得不到复用

- 不能用index来作为key
  - 因为在对列表进行删除或移动操作的时候会引起更新问题
*/

/*
- V-DOM 的优势
  - DOM 引擎 、JS 引擎相互独立，又工作在同一线程。
    JS 代码调用 DOM API 必须挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎，DOM 重绘后再转换可能有的返回值，
    最后激活 JS 引擎并继续执行。若频繁的 DOM API 调用，重新计算布局、重新绘制图像会引起更大的性能消耗。
  - 优势：
    - V-DOM 不会立马进行重排和重绘
    - V-DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版重绘，减少过多的 DOM 节点排版与重绘损耗
    - V-DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部
*/
