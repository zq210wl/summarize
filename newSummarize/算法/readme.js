/*
- 算法工具
  - 算法可视化：https://github.com/algorithm-visualizer/algorithm-visualizer
  - 算法动画：https://visualgo.net/zh

- 常考算法题
  - https://interview.poetries.top/docs/excellent-docs/%E9%AB%98%E9%A2%91%E6%A8%A1%E5%9D%97.html#_1-typeof%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD

- 各种排序算法
  - https://interview.poetries.top/docs/excellent-docs/18-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html

- 计算机通识
  - https://interview.poetries.top/docs/excellent-docs/19-%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86.html

- 从容应对算法题目
  - https://interview.poetries.top/docs/excellent-docs/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97.html#%E4%BA%94%E3%80%81%E4%B8%80%E9%9D%A2-4-%E4%BB%8E%E5%AE%B9%E5%BA%94%E5%AF%B9%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE

- 各种算法视频讲解
  - https://space.bilibili.com/525438321/channel/collectiondetail?sid=180037
*/

/*
- 递归（尾递归）
  - 解释：函数自己调用自己
  - 要点：确定递归的结束条件
  - 场景：递归用于树状结构的查询、复制等操作
- while循环
  - 要点：设置初始值和终止条件，在一个范围内重复运算
  - 场景：多次进行同样的运算
- 双指针
  - 解释：定义两个指向数组下标的变量作为标示
  - 分类：两个都指向一个数组；两个分别指向两个数组；
  - 场景：
- 深度优先遍历（DFS - 用栈或递归来辅助实现）
  - 场景：树的先序遍历
- 广度优先遍历（BFS - 用队列来辅助实现）
  - 场景：树的层次遍历

*/

/*
- 数据结构
  - 数组
    - js中 array 的 shift、unshift、pop、push 操作
      - shift、unshift 操作是非常耗性能的
      - pop、push 操作不耗性能
    - 稀疏数组 ？？
  - 栈
    - js中栈的封装
      - 可以用array来构造，也可以用链表
  - 队列
    - 不要用array构造，用链表来构造
  - 链表
    - 单向
    - 双向
    - 循环
  - 集合
    - Set：js中本身内置的集合数据结构 
    - 特点：不重复、无序
    - 场景：求两个集合的并集、交集、差集
  - 字典
    - 解释：key -> vlaue 形式
    - Object：js中存在的结构
    - 散列表
      - Map：js中本身内置的结构
        - 特点：key可以是对象
      - WeakMap
        - 特点：key只能是对象
        - 作用：当key对应的对象引用不存在了，那么WeakMap中对应的键值对都会被垃圾回收掉，内存空间被释放 
      - HashMap
      - HashTable
  - 树（也是一种存储数据的结构）
    - 二叉树
    - 二叉搜索树
      - 解释：只允许在左侧节点存储比父节点小的值，在右侧节点存储比父节点大的值
      - 插入规则：在插入节点的时候，会从根节点开始搜索，如果比根节点大，那么走右边，小的话走左边，
             所以树的左边最大的值一定比右边最小的值小
      - 特点：
        - 一个父节点的左边的子树的所有节点一定都小于这个父节点；右边反之；
        - 左边最大的值一定比右边最小的值小
        - 最小值一定是在最左边；最大值一定是在最右边
      - 遍历（下面的命名是根据根节点的位置来起的名字）
        - 中序遍历：左、根、右
        - 先序遍历：根、左、右
        - 后序遍历：左、右、根
    - 二叉堆（以【数组】形式存储，所以操作的都是数组）
      - 解释：（最小堆）父节点大于子节点，或（最大堆）父节点小于子节点，而且如果是最后一层必须是先有左边才能有右边
      - 根据父节点的下标来找到对应它的左右节点的下标
        - leftIndex = 2 * parentIndex + 1
        - rightIndex = 2 * parentIndex + 2
      - 根据子节点的下标来找到父节点的下标
        - parentIndex = Math.floor((childIndex - 1) / 2)
      - 插入节点：先把节点插入到数组的末尾作为最后一个节点，然后再从树的最后一个字节点开始往上比较交换，最后找出此节点的下标
      - 删除节点：先把最后一个节点移动到要删除的节点的位置，然后再从root节点开始往下比较交换，最后找出此节点的下标
*/

/*
- 排序算法
  - 冒泡排序
  - 选择排序
  - 归并排序
    - 核心思想：
      - 归：先递归从中间切分位最小长度的数组
      - 并：然后对两个【有序数组】进行合并排序
  - 快速排序
    - 核心思想：
      - 先随便找一个基准值（一般取第一个）
      - 然后找出所有比基准值小的放在左边，比基准值大的放在右边
      - 最后把他们都合并起来
    - 寻找的方法就是：不断的挖坑、填坑
  - 计数排序
    - 利用数组的下标本来就是排序好的特性
    - 缺点：会产生稀疏数组，浪费内存
  - 随机算法（洗牌算法）
    - 解释：对数组进行随机排序
    - 核心思想：随机生成一个数字，作为将要被洗的数的下标：Math.floor(Math.random() * (i + 1))
              然后把这个数跟数组最后一个数进行交换，这样就把这个数字洗到数组最后了，这样就完成了一次洗牌，
              然后不断的循环上面的步骤
*/

/*
- 搜索算法
  - 顺序搜索
  - 二分搜索
    - 原理：先排序，然后取中间的数，比中间数小，就从左边找，比中间数大，就从右边找
*/

/*
- 记忆搜索
  - 把已经搜索过的节点的结果先保存起来，供之后用
*/

/*
- 动态规划（英语：Dynamic programming，简称DP）
  - 包括哪些典型问题：
    - 背包问题
    - 最长公共子序列

  - 0/1背包问题（0/1的意思就是针对某一个东西只能选0次或1次，分拿和不拿两种情况来算）
    - https://www.bilibili.com/video/BV1K4411X766/?spm_id_from=333.337.search-card.all.click&vd_source=555766b712a2e03a84b474a38afc330a
    - https://www.bilibili.com/video/BV1cg411g7Y6/?spm_id_from=333.337.search-card.all.click&vd_source=555766b712a2e03a84b474a38afc330a
    - https://segmentfault.com/a/1190000012829866
    - DP数组：构建 dp[i][j] 二维数组，用两个嵌套for循环来遍历构建，第一层是i，第二层是j
      - 第二层j代表的是：背包最大容量依次递减1，直到0
    - 要会用二维数组来存储二维表格数组，表格的右下角的值就是所求的最大符合条件的值
    - 初始化第一行和第一列的数据：因为后面的都是依据前面来推算的，只要知道就可以根据公式来推算出后面的值
    - 动态【转移】方程式：分情况（拿或不拿）总结出对应的二元一次方程等式
    - 滚动数组的实现方式：是一个一维度数组dp[j]，从右往左不断的替换数组中的元素，有对应的方程式
  - 完全背包问题（针对某一个东西可以选多次，数量【无限】，分拿和不拿两种情况来算）
    - https://www.bilibili.com/video/BV1pY4y1J7na/?spm_id_from=333.337.search-card.all.click&vd_source=555766b712a2e03a84b474a38afc330a
  - 多重背包问题（针对某一个东西可以选多次，数量【有限】，分拿和不拿两种情况来算）
    - https://www.bilibili.com/video/BV1C7411K79w?p=3&vd_source=555766b712a2e03a84b474a38afc330a
*/

/*
- 回溯算法（backtracking，回溯搜索 - 一种暴力搜索法）
  - 解决的问题类型：
    - 组合
    - 切割
    - 子集
    - 排列
    - 棋牌
*/


/*
算法归类学习和技巧：
https://labuladong.github.io/algo/di-ling-zh-bfe1b/shuang-zhi-fa4bd/
*/

/*
- 算法心得
  - 通过画图来辅助思考和写代码
  - 分类解决：
    - 把各种情况都考虑到，然后用 if else 分别处理，总能找到解决办法
  - 把问题拆分成子问题去解决
    - 用 for 循环来一个一个的处理子问题
    - 二位问题就需要用两个 for 循环来处理子问题，确定好每层循环的用意
  - 边界问题可以直接通过带入来验证得出
*/

/*
- 一些算法问题
  - 写一个将10进制转换成任何进制的方法
  - JS中的迭代器是干什么用的？有什么应用场景？
  - 链表反转
*/