<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width"></meta>
    <title>手动实现Promise</title>
</head>
<body>
<script>
    // todo: 实现Promsie.resolve()方法
    // reject 和 then中的reject 个私其职，
    //   reject只管改变状态，以及当前执行中是否有正在等待的reject回调列表
    //   then中的reject直观看当前当前执行的时候，是否状态为reject，如果是，就马上执行，不需要往reject回调列表添加，
    //        只有执行的时候当前状态为pending才需要往reject回调列表添加回调
    function myPromise(callback) {
        this.pendingStatus = 'pending';
        this.fulFilledStatus = 'fulfilled';
        this.rejectedStatus = 'reject';

        this.stauts = this.pendingStatus;
        this.value = undefined;

        this.pendingFulfilledCallback = [];
        this.pendingRejectedCallback = [];

        this.resolve = this.resolve.bind(this);
        this.reject = this.reject.bind(this);

        try {
            callback(this.resolve, this.reject);
        } catch (err) {
            this.reject(err);
        }
    };

    myPromise.prototype.resolve = function(value) {
        if (this.stauts === this.pendingStatus) {
            this.stauts = this.fulFilledStatus;
            this.value = value;
            setTimeout(() => {
                this.pendingFulfilledCallback.forEach(fn => {
                    fn(value);
                });
            });
        }
    };

    myPromise.prototype.reject = function(reason) {
        if (this.stauts === this.pendingStatus) {
            this.stauts = this.rejectedStatus;
            this.value = reason;
            setTimeout(() => {
                this.pendingRejectedCallback.forEach(fn => {
                    fn(reason);
                });
                if (this.pendingRejectedCallback.length === 0) {
                    throw reason;
                }
            });
        }
    };

    myPromise.prototype.then = function(fulfilledCallback, rejectedCallback) {
        var nextResolve = null;
        var nextReject = null;
        var nextPromise = new myPromise((resolve, reject) => {
            nextResolve = resolve;
            nextReject = reject;
        });

        if (this.stauts === this.fulFilledStatus) {
            // 模拟微任务
            setTimeout(() => {
                if (typeof fulfilledCallback === 'function') {
                    let res = null;
                    try {
                        res = fulfilledCallback(this.value);
                    } catch (err) {
                        nextReject(err);
                    }
                    if (res instanceof Promise) {
                        res.then(nextResolve, nextReject);
                    } else {
                        nextResolve(res);
                    }
                } else {
                    nextResolve(this.value);
                }
            });
            return nextPromise;
        }

        if (this.stauts === this.rejectedStatus) {
            // 模拟微任务
            setTimeout(() => {
                if (typeof rejectedCallback === 'function') {
                    let res = null;
                    try {
                        res = rejectedCallback(this.value);
                    } catch (err) {
                        nextReject(err);
                    }
                    if (res instanceof Promise) {
                        res.then(nextResolve, nextReject);
                    } else {
                        nextResolve(res);
                    }
                } else {
                    nextReject(this.value);
                }
            });
            return nextPromise;
        }

        if (this.stauts === this.pendingStatus) {
            // 加入待执行队列
            this.pendingFulfilledCallback.push((value) => {
                if (typeof fulfilledCallback === 'function') {
                    let res = null;
                    try {
                        res = fulfilledCallback(this.value);
                    } catch (err) {
                        nextReject(err);
                    }
                    if (res instanceof Promise) {
                        res.then(nextResolve, nextReject);
                    } else {
                        nextResolve(res);
                    }
                } else {
                    nextResolve(this.value);
                }
            });
            // 加入待执行队列
            this.pendingRejectedCallback.push((value) => {
                if (typeof rejectedCallback === 'function') {
                    let res = null;
                    try {
                        res = rejectedCallback(this.value);
                    } catch (err) {
                        nextReject(err);
                    }
                    if (res instanceof Promise) {
                        res.then(nextResolve, nextReject);
                    } else {
                        nextResolve(res);
                    }
                } else {
                    nextReject(this.value);
                }
            });
            return nextPromise;
        }

    };

    myPromise.prototype.catch = function(rejectedCallback){
        this.then(null, rejectedCallback);
    };



    new myPromise((resolve, reject) => {
        setTimeout(() => {
            console.log(555);
            reject(444444);
        }, 1000);
    })
    .then(null, null)
    .then(res => {
        console.log('执行到我了');
        console.log(res);
    }, err => {
        console.log('捕获到错误A：', err);
    })
    .catch(err => {
        console.log('捕获到错误B：', err);
    });
    
</script>
</body>
</html>